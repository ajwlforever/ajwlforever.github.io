<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虞启贤</title>
  <icon>https://www.gravatar.com/avatar/2abcf6a5f72bad68445b90d7a2eeede4</icon>
  <subtitle>虞启贤的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.yqxblog.top/"/>
  <updated>2019-09-23T15:37:45.556Z</updated>
  <id>www.yqxblog.top/</id>
  
  <author>
    <name>虞启贤</name>
    <email>2353350597@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法（二）动态规划</title>
    <link href="www.yqxblog.top/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%BA%8C/"/>
    <id>www.yqxblog.top/算法/算法二/</id>
    <published>2019-09-23T00:40:00.000Z</published>
    <updated>2019-09-23T15:37:45.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划（Dynamic-progroming-DP）"><a href="#动态规划（Dynamic-progroming-DP）" class="headerlink" title="动态规划（Dynamic progroming,DP）"></a>动态规划（Dynamic progroming,DP）</h1><h2 id="一、什么是动态规划？"><a href="#一、什么是动态规划？" class="headerlink" title="一、什么是动态规划？"></a>一、什么是动态规划？</h2><p>动态规划就是将待求解问题分解成若干个子问题，先求解子问题，然后在从这些子问题的解得到原问题的解。<br>(通常会画一个矩阵。。。)</p><h2 id="二、设计动态规划算法的步骤"><a href="#二、设计动态规划算法的步骤" class="headerlink" title="二、设计动态规划算法的步骤"></a>二、设计动态规划算法的步骤</h2><p>(1). 找出最优解的性质，并刻画其结构特征<br>(2). 递归的定义最优值<br>(3). 从底向上计算出最优值</p><h2 id="三、动态规划的特征"><a href="#三、动态规划的特征" class="headerlink" title="三、动态规划的特征"></a>三、动态规划的特征</h2><h3 id="4-1-矩阵连乘积问题"><a href="#4-1-矩阵连乘积问题" class="headerlink" title="4.1 矩阵连乘积问题"></a>4.1 矩阵连乘积问题</h3><p>题目:给定n个矩阵{A1,A2,A3,……,An}，其中Ai与A(i+1)是可乘的，i=1,2,3,……,n-1。考察这n个矩阵的连乘积A1,A2,A3,……,An。<br>具体例子书上有 P78</p><ul><li>A1是50*10  A2是10*40 A3是40*30 A430*5</li><li>A1*A3d的运算次数就是 50*30  </li><li>考虑这四个的排列</li></ul><h4 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h4><p>完全加括号的矩阵连乘积可递归地定义为：</p><pre><code>（1）单个矩阵是完全加括号的；（2）矩阵连乘积A是完全加括号的，则A可表示为2个完全加括号的矩阵连乘积B和C的乘积并加括号，即A=(BC)   例如，矩阵连乘积A1A2A3A4有5种不同的完全加括号的方式：(A1(A2(A3A4)))，(A1((A2A3)A4))，((A1A2)(A3A4))，((A1(A2A3))A4)，(((A1A2)A3)A4)。每一种完全加括号的方式对应于一个矩阵连乘积的计算次序，这决定着作乘积所需要的计算量。  看下面一个例子，计算三个矩阵连乘{A1，A2，A3}；维数分别为10*100 , 100*5 , 5*50 按此顺序计算需要的次数((A1*A2)*A3):10X100X5+10X5X50=7500次，按此顺序计算需要的次数(A1*(A2*A3)):10*5*50+10*100*50=52500次  所以问题是：如何确定运算顺序，可以使计算量达到最小化。      </code></pre><p>————————————————</p><p> m[i][j]是矩阵i到矩阵j的最小次数 （动态规划就是分解成子问题） ，所有可以看成 m[i][k]+m[k][j]+p[i-1]\p[k]\p[j]<br> 然后就和书上的那个图是一样的了。<br> <img src="https://i.loli.net/2019/09/23/URO1MNHzy3AIB2t.png" alt></p><ol><li>穷举法</li></ol><p>画出m[i][j]的方阵<br><img src="https://i.loli.net/2019/09/23/BfKLml6Av8Q3VhH.png" alt><br>根据方阵，我们可以看出更具上面那个方程，矩阵下半部分是不用放数据的，因为 i&lt;=j<br>然后看 i&lt;j的时候， 找中间值（子问题） 那就一定有k&lt;j，所有可以一条对角线一条对角线的算。<br>第i条对角线的某个值就从 第一条对角线找起。这样m[i][j]就会都是i-j的最小值</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define NUM 51</span><br><span class="line">int p[NUM];</span><br><span class="line">int m[NUM][NUM];</span><br><span class="line">int s[NUM][NUM];</span><br><span class="line"></span><br><span class="line">void MatrixChain(int n)</span><br><span class="line">&#123;</span><br><span class="line"> for(int i=1; i&lt;=n;i++) m[i][i] = 0;  //第一条对角线全是0</span><br><span class="line"></span><br><span class="line"> for(int r=2 ; r&lt;=n ; r++)  //从第2条对角线开始计算</span><br><span class="line"> for(int i=1 ; i&lt;=n-r+1;i++)   //第r条对角线的i</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            int j = i+r-1; //第r条对角线的j</span><br><span class="line">            m[i][j] = m[i+1][j]+p[i-1]*p[i]*p[j];  //初始化m[i][j],从i处断开</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            for(int k = i+1 ; k&lt;j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];//动态规划方程计算   核心代码</span><br><span class="line">                if(t&lt;m[i][j])&#123;m[i][j]=t;s[i][j]=k;&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"> //memset(m,0,sizeof(m));</span><br><span class="line"> //memset(s,0,sizeof(s));</span><br><span class="line">  int n = 6;</span><br><span class="line">  p[0]=50;</span><br><span class="line">  p[1]=10;</span><br><span class="line">  p[2]=40;</span><br><span class="line">  p[3]=30;</span><br><span class="line">  p[4]=5;</span><br><span class="line">  p[5]=20;</span><br><span class="line">  p[6]=15;</span><br><span class="line"> MatrixChain(n);</span><br><span class="line">for(int i = 1; i&lt;=n ;i++)</span><br><span class="line">  &#123;</span><br><span class="line">      for(int j = 1; j&lt;=n ;j++)</span><br><span class="line">      &#123;</span><br><span class="line">      if(i&lt;j)</span><br><span class="line">      cout&lt;&lt;m[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">      else cout&lt;&lt;0&lt;&lt;&quot; &quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      cout&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;m[1][2]&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;m[1][6]&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;s[1][6]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>2 递推法  （和上面的公式是一样的，只不过在写程序方面用的是递归法）</code></pre><p>  画括号:<br> <img src="https://i.loli.net/2019/09/23/zSHYNPZstF9MQOp.png" alt></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">//3d1-1 重叠子问题的递归最优解</span><br><span class="line">//A1 30*35 A2 35*15 A3 15*5 A4 5*10 A5 10*20 A6 20*25</span><br><span class="line">//p[0-6]=&#123;30,35,15,5,10,20,25&#125;</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"> </span><br><span class="line">const int L = 7;</span><br><span class="line"> </span><br><span class="line">int RecurMatrixChain(int i,int j,int **s,int *p);//递归求最优解</span><br><span class="line">void Traceback(int i,int j,int **s);//构造最优解</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int p[L]=&#123;30,35,15,5,10,20,25&#125;;</span><br><span class="line"> </span><br><span class="line">    int **s = new int *[L];</span><br><span class="line">for(int i=0;i&lt;L;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">s[i] = new int[L];  </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">cout&lt;&lt;&quot;矩阵的最少计算次数为：&quot;&lt;&lt;RecurMatrixChain(1,6,s,p)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;矩阵最优计算次序为：&quot;&lt;&lt;endl;</span><br><span class="line">Traceback(1,6,s);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int RecurMatrixChain(int i,int j,int **s,int *p)</span><br><span class="line">&#123;</span><br><span class="line">if(i==j) return 0;</span><br><span class="line">int u = RecurMatrixChain(i,i,s,p)+RecurMatrixChain(i+1,j,s,p)+p[i-1]*p[i]*p[j];</span><br><span class="line">s[i][j] = i;</span><br><span class="line"> </span><br><span class="line">for(int k=i+1; k&lt;j; k++)</span><br><span class="line">&#123;</span><br><span class="line">int t = RecurMatrixChain(i,k,s,p) + RecurMatrixChain(k+1,j,s,p) + p[i-1]*p[k]*p[j];</span><br><span class="line">if(t&lt;u)</span><br><span class="line">&#123;</span><br><span class="line">u=t;</span><br><span class="line">s[i][j]=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return u;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Traceback(int i,int j,int **s)</span><br><span class="line">&#123;</span><br><span class="line">if(i==j) return;</span><br><span class="line">Traceback(i,s[i][j],s);</span><br><span class="line">Traceback(s[i][j]+1,j,s);</span><br><span class="line">cout&lt;&lt;&quot;Multiply A&quot;&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;s[i][j];</span><br><span class="line">cout&lt;&lt;&quot; and A&quot;&lt;&lt;(s[i][j]+1)&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-最长公共子序列"><a href="#4-3-最长公共子序列" class="headerlink" title="4.3 最长公共子序列"></a>4.3 最长公共子序列</h3><p>问题：给定两个字符串，求解这两个字符串的最长公共子序列（Longest Common Sequence）。比如字符串1：BDCABA；字符串2：ABCBDAB</p><p>则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA</p><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>两个序列进行比较因为这个不是对等的比较，那就只能枚举了。</p><p>把这个问题分解成子问题，用c[i][j]表示 A序列的i到B序列的j的最长公共子序列</p><p><strong>c[i][j]从c[1][1]开始讨论。<br>c[0][0] = 0 ;<br>若A[i]==B[j]  那么 c[i][j] = c[i-1][j-1]+1<br>若A[i]!=B[j]  那么 c[i][j] = max{c[i-1][j],c[i][j-1]}<br>核心方程get，那么接下来考虑怎么样去循环计算，确保上一个子问题是解决的。<br>根据这两个式子，都是i-1，j-1 那直接双重循环即可</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define NUM 100</span><br><span class="line">int c[NUM][NUM];</span><br><span class="line">int b[NUM][NUM]; //记录路径</span><br><span class="line"></span><br><span class="line">void LCSLength (int m,int n ,char A[],char B[])</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    //将第0行，第0列归0</span><br><span class="line">    for(i=0 ; i&lt;m ;i++)&#123; c[i][0] = 0; cout&lt;&lt;A[i];&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">     for(i=0 ; i&lt;n ;i++)&#123; c[0][i] = 0;cout&lt;&lt;B[i];&#125;</span><br><span class="line">   cout&lt;&lt;endl;</span><br><span class="line">     //直接双重循环递归</span><br><span class="line">     for(i=1; i&lt;= m;i++)</span><br><span class="line">     for(j=1; j&lt;= n;j++)</span><br><span class="line">     &#123;</span><br><span class="line">         cout&lt;&lt;&quot;A[&quot;&lt;&lt;i&lt;&lt;&quot;-1]:&quot;&lt;&lt;A[i-1]&lt;&lt;&quot; B[&quot;&lt;&lt;j&lt;&lt;&quot;-1]:&quot;&lt;&lt;B[j-1]&lt;&lt;endl;</span><br><span class="line">         if(A[i-1]==B[j-1])</span><br><span class="line">        &#123;</span><br><span class="line">           c[i][j] = c[i-1][j-1]+1;</span><br><span class="line">           b[i][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">         else</span><br><span class="line">         if(c[i-1][j]&gt;=c[i][j-1])</span><br><span class="line">         &#123;</span><br><span class="line">           c[i][j]=c[i-1][j];</span><br><span class="line">              b[i][j] = 2;</span><br><span class="line">         &#125;else &#123;</span><br><span class="line">              c[i][j]=c[i][j-1];</span><br><span class="line">              b[i][j] = 3;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char A[] = &#123;&apos;B&apos;,&apos;D&apos;,&apos;C&apos;,&apos;A&apos;,&apos;B&apos;,&apos;A&apos;&#125;;</span><br><span class="line">    char B[] = &#123;&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;B&apos;,&apos;D&apos;,&apos;A&apos;,&apos;B&apos;&#125;;</span><br><span class="line">    int m = 6;</span><br><span class="line">    int n = 7;</span><br><span class="line">    LCSLength(m,n,A,B);</span><br><span class="line">    cout&lt;&lt;c[5][6]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  for(int i=0; i&lt;= m;i++)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">    for(int j=0; j&lt;= n;j++)</span><br><span class="line">     &#123;</span><br><span class="line">         cout&lt;&lt;c[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     cout&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  for(int i=0; i&lt;= m;i++)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">    for(int j=0; j&lt;= n;j++)</span><br><span class="line">     &#123;</span><br><span class="line">         cout&lt;&lt;b[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     cout&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/09/23/if4zmB6ynUhJg9O.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划（Dynamic-progroming-DP）&quot;&gt;&lt;a href=&quot;#动态规划（Dynamic-progroming-DP）&quot; class=&quot;headerlink&quot; title=&quot;动态规划（Dynamic progroming,DP）&quot;&gt;&lt;/a&gt;动态规划（
      
    
    </summary>
    
      <category term="算法" scheme="www.yqxblog.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="www.yqxblog.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法（一）递归与分治</title>
    <link href="www.yqxblog.top/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%80/"/>
    <id>www.yqxblog.top/算法/算法一/</id>
    <published>2019-09-11T00:40:00.000Z</published>
    <updated>2019-09-18T06:26:31.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><h1 id="一、集合的全排列问题"><a href="#一、集合的全排列问题" class="headerlink" title="一、集合的全排列问题"></a>一、集合的全排列问题</h1><h3 id="1-递归实现全排列"><a href="#1-递归实现全排列" class="headerlink" title="1.递归实现全排列"></a>1.递归实现全排列</h3><ul><li>简单的递归。</li><li>11交换12交换…………….1n交换</li><li>22交换23交换……2n交换</li><li>…………………</li><li>n-1(n-1) n(n-1)</li><li>nn交换</li><li>上面是所有的递归从11-nn；是第一层到最后一层</li><li>递归就是从最后一层的逐个返回，一层层一个个的返回到第层(到哪一层了都是逐个返回未返回过的)。所以第一个结果是 11-22-nn 第二个结果是 11-22-(n-1)（n）…..</li><li></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void Perm(int list[],int k,int m)</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    if(k==m)&#123;   //已经搜索到了最后</span><br><span class="line">      for(int i=0;i&lt;=m;i++)</span><br><span class="line">      &#123;   </span><br><span class="line">           cout&lt;&lt;list[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">      &#125;</span><br><span class="line">     cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else &#123;</span><br><span class="line"></span><br><span class="line">        for(int j = k ;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(list[k],list[j]);  //交换</span><br><span class="line">            Perm(list,k+1,m);</span><br><span class="line">            swap(list[k],list[j]);  //还原</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int *&amp;x, int *&amp;y) &#123;</span><br><span class="line">    int *temp = y;</span><br><span class="line">    y = x;</span><br><span class="line">    x = temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">   int list[] = &#123;1,2,3,4,5,6&#125;;</span><br><span class="line">    Perm(list,0,3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/09/10/3iRAOmbGUBsKX1Y.png" alt></p></li></ul><h1 id="二、整数划分问题"><a href="#二、整数划分问题" class="headerlink" title="二、整数划分问题"></a>二、整数划分问题</h1><h3 id="1-只计算整数划分的数量"><a href="#1-只计算整数划分的数量" class="headerlink" title="1.只计算整数划分的数量"></a>1.只计算整数划分的数量</h3><ul><li>f(n,m)表示n这个数的m划分（划分的都比m小）的数量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Split(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">    if(n==1||m==1) return 1;   //递归到底，返回</span><br><span class="line">    else if(n&lt;m)return Split(n,n);  //n&lt;m的情况，只能划分为f(n,n)</span><br><span class="line">    else if(n==m) return Split(n,n-1)+1;  //f(n,n)的情况 直接划分，分为f(n,n-1)+1  (这一步可以和上一步合并)</span><br><span class="line">    else if(n&gt;m) return Split(n-m,m)+Split(n,m-1);  //n&gt;m 划分为 m-1和m 的划分  （其实上一步也是m和m-1的划分，但上一步属于特殊情况要算出后面那个+1，不然递归就会出错，无限递归）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int a=10;</span><br><span class="line">  cout&lt;&lt;Split(a,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result: 42</span><br></pre></td></tr></table></figure><h1 id="三、循环赛日程表"><a href="#三、循环赛日程表" class="headerlink" title="三、循环赛日程表"></a>三、循环赛日程表</h1><p>  题目：设有n=2^k个运动员要进行网球循环赛。现要设计一个满足以下要求的比赛日程表：</p><p> (1)每个选手必须与其他n-1个选手各赛一次；<br> (2)每个选手一天只能参赛一次；<br> (3)循环赛在n-1天内结束。</p><p>请按此要求将比赛日程表设计成有n行和n-1列的一个表。在<strong>表中的第i行，第j列处填入第i个选手在第j天所遇到的选手</strong>。其中1≤i≤n，1≤j≤n-1。</p><blockquote><p>思路： <img src="https://i.loli.net/2019/09/11/HeIqmUidNPhwpTS.png" alt><br>     这是一个两位选手的时程表,可以看出是红线这样的排列，再看四位选手的<br>     <img src="https://i.loli.net/2019/09/11/Ep5g67XCN29fzWO.png" alt><br>     利用分治思想把n个选手分到2分之一递归进行排列（右上到左下，坐下到右上）;<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX 100</span><br><span class="line">int a[MAX][MAX];</span><br><span class="line">// to是要复制到的位置，from是源位置</span><br><span class="line">void Copy(int tox,int toy,int fromx,int fromy ,int r)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0 ; i &lt; r; i++)</span><br><span class="line">       for(int j = 0 ; j &lt; r; j++)</span><br><span class="line">       &#123;</span><br><span class="line">            a[tox+i][toy+j] = a[fromx+i][fromy+j];</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">//构造循环赛程日列表，选手的数量是2的k次方</span><br><span class="line">void Table(int k)</span><br><span class="line">&#123;</span><br><span class="line">   int i,r ;</span><br><span class="line">    int n = 1&lt;&lt;k;  //2的k次方</span><br><span class="line">    for(int i =0 ;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[0][i] = i+1;  //先将第一排构建出来；</span><br><span class="line">    &#125;</span><br><span class="line">    for(r=1 ; r&lt;n ; r&lt;&lt;=1)  //呈2的次方来一次次进行转移</span><br><span class="line">        for(i=0 ; i&lt;n ; i+=2*r)  //一次转移是一大块抄走，所以是2*r</span><br><span class="line">        &#123;</span><br><span class="line">           Copy(r,r+i,0,i,r);  //左上角移动到右下角</span><br><span class="line">            Copy(r,i,0,r+i,r);  //右上角移动到左下角</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">   Table(4);</span><br><span class="line">   for(int i=0 ; i&lt;16 ; i++)</span><br><span class="line">      &#123;</span><br><span class="line">       for(int j=0 ; j&lt;16 ; j++)</span><br><span class="line">           cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot; ;</span><br><span class="line">       cout&lt;&lt;endl;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="四、二分搜索技术"><a href="#四、二分搜索技术" class="headerlink" title="四、二分搜索技术"></a>四、二分搜索技术</h1><h1 id="五、输出油管问题"><a href="#五、输出油管问题" class="headerlink" title="五、输出油管问题"></a>五、输出油管问题</h1><p><img src="https://i.loli.net/2019/09/11/9lUkbYXLciMsyEN.png" alt=" 中位数定理:"></p><blockquote><p>中位数定理：给定一个数列，中位数有这样的性质 ：所有数与中位数的绝对差之和最小<br> 所以这个题就变得简单了，只是y方向的，所以直接求中位数即可，将数据排序取中位数，在计算和所有油管距离之和即是的答案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int x;</span><br><span class="line">    int a[1000];</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    for(int k=0;k&lt;n;k++)</span><br><span class="line">      cin&gt;&gt;x&gt;&gt;a[k];</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    int min = 0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    min += (int)fabs(a[i]-a[n/2]);</span><br><span class="line">    cout&lt;&lt;min&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="六、士兵排队问题"><a href="#六、士兵排队问题" class="headerlink" title="六、士兵排队问题"></a>六、士兵排队问题</h1><p><img src="https://i.loli.net/2019/09/11/n65y7rQekMAzthX.png" alt><br>输出油管问题的升级版<br>2个轴 y轴上面和上面那个题一样<br>x轴上要到的位置是 k,k+1……k+(n-1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,i,x[10001],y[10001];</span><br><span class="line">  int min;</span><br><span class="line">  while(cin&gt;&gt;n)</span><br><span class="line">  &#123;</span><br><span class="line">      for(i=0;i&lt;n;i++)</span><br><span class="line">          cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">       sort(x,x+n);</span><br><span class="line">       sort(y,y+n);</span><br><span class="line">       for(i=0;i&lt;n;i++)</span><br><span class="line">        x[i]-=i;</span><br><span class="line">        sort(x,x+n);</span><br><span class="line">       min =0;</span><br><span class="line">         cout&lt;&lt;x[n/2]&lt;&lt;&quot; &quot;&lt;&lt;y[n/2]&lt;&lt;endl;</span><br><span class="line">       for(i=0;i&lt;n;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           min+=abs(x[i]-x[n/2]);</span><br><span class="line">           min+=abs(y[i]-y[n/2]);</span><br><span class="line">       &#125;</span><br><span class="line">       cout&lt;&lt;(min)&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、半数集问题"><a href="#七、半数集问题" class="headerlink" title="七、半数集问题"></a>七、半数集问题</h1><p><img src="https://i.loli.net/2019/09/11/dWgUiQPYHSIVJGT.png" alt></p><p>这个题主要是将公式能总结出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int a[1001]; //存放拆过的数</span><br><span class="line"></span><br><span class="line">int Comp(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int ans = 1;</span><br><span class="line"></span><br><span class="line">   if(a[n]&gt;0)return a[n];</span><br><span class="line"></span><br><span class="line">   for(int i=0 ;i&lt;n/2;i++)</span><br><span class="line">   ans+=Comp(i);   //往后递归；</span><br><span class="line">   a[n]=ans;   //存放已经计算出来的值</span><br><span class="line">   return ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"> int n ;</span><br><span class="line"> while(cin&gt;&gt;n)</span><br><span class="line"> &#123;</span><br><span class="line">     memset(a,0,sizeof(a));</span><br><span class="line">      a[1]=1;</span><br><span class="line">      cout&lt;&lt;Comp(n);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="八、集合的划分问题"><a href="#八、集合的划分问题" class="headerlink" title="八、集合的划分问题"></a>八、集合的划分问题</h1><p><img src="https://i.loli.net/2019/09/11/gPCjQrw5RE46tbp.png" alt></p><ul><li>三个数的集合划分为两个子集合， 就是2个数一个集合，1个数一个集合。</li><li>n个数划分为k个集合大致上就是 </li><li><p>1)若k==1，则f(n,k)=1;</p><p>2)若n==m，则f(n,k)=1;</p><p>3)若非以上两种情况，f(n,k)可以由下面两种情况构成</p><p>  a.向n-1个元素划分成的m个集合里面添加一个新的元素，则有k*f(n-1,k)种方法；</p><p>  b.向n-1个元素划分成的m-1个集合里添加一个由一个元素形成的独立的集合，则有f(n-1,k-1)种方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long s(int n,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if((n&lt;k)||(k==0)) return 0;</span><br><span class="line">    if((k==1)||(k==n)) return 1;</span><br><span class="line">    return s(n-1,k-1)+k*s(n-1,k);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    cout&lt;&lt;s(n,k)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递归和分治&quot;&gt;&lt;a href=&quot;#递归和分治&quot; class=&quot;headerlink&quot; title=&quot;递归和分治&quot;&gt;&lt;/a&gt;递归和分治&lt;/h1&gt;&lt;h1 id=&quot;一、集合的全排列问题&quot;&gt;&lt;a href=&quot;#一、集合的全排列问题&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="算法" scheme="www.yqxblog.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="www.yqxblog.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>unity_Magical voxel创建结构体</title>
    <link href="www.yqxblog.top/unity/unity_Magical%20voxel%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>www.yqxblog.top/unity/unity_Magical voxel创建结构体/</id>
    <published>2019-09-05T15:00:00.000Z</published>
    <updated>2019-09-23T15:39:45.150Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要目的，让magical voxel导出的vox 可以一个个像素块的方式推积</li></ul><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="1-将vox利用voxelImporter导入之后勾选上转换为structs"><a href="#1-将vox利用voxelImporter导入之后勾选上转换为structs" class="headerlink" title="1.将vox利用voxelImporter导入之后勾选上转换为structs"></a>1.将vox利用voxelImporter导入之后勾选上转换为structs</h3><h3 id="2-再场景中创建空物体，加载这个物体，为其加上CreateCubes代码"><a href="#2-再场景中创建空物体，加载这个物体，为其加上CreateCubes代码" class="headerlink" title="2.再场景中创建空物体，加载这个物体，为其加上CreateCubes代码"></a>2.再场景中创建空物体，加载这个物体，为其加上CreateCubes代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  //* 将structs遍历上色 structs里面已经有了 每个块的位置，颜色。</span><br><span class="line">  每一个像素方块上色要先创建Cube，再确定其位置，父亲。</span><br><span class="line">  最后为其打上材质,renderer,rigbody</span><br><span class="line">  *//</span><br><span class="line">public class CreateCubes : MonoBehaviour</span><br><span class="line">   &#123;</span><br><span class="line">       public VoxelStructure voxelStructure;</span><br><span class="line"></span><br><span class="line">       private Material[] materials;</span><br><span class="line"></span><br><span class="line">       public void Awake()</span><br><span class="line">       &#123;</span><br><span class="line">           if (voxelStructure == null) return;</span><br><span class="line"></span><br><span class="line">           materials = new Material[voxelStructure.palettes.Length];</span><br><span class="line">           for (int i = 0; i &lt; voxelStructure.palettes.Length; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               materials[i] = new Material(Shader.Find(&quot;Standard&quot;));</span><br><span class="line">               materials[i].name = string.Format(&quot;Palette &#123;0&#125;&quot;, i);</span><br><span class="line">               materials[i].color = voxelStructure.palettes[i];</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           for (int i = 0; i &lt; voxelStructure.voxels.Length; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               var go = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">               go.name = string.Format(&quot;&#123;0&#125; : (&#123;1&#125;, &#123;2&#125;, &#123;3&#125;)&quot;, i, voxelStructure.voxels[i].x, voxelStructure.voxels[i].y, voxelStructure.voxels[i].z);</span><br><span class="line">               go.transform.localPosition = voxelStructure.voxels[i].position;</span><br><span class="line">               go.transform.SetParent(transform);</span><br><span class="line">               &#123;</span><br><span class="line">                   var renderer = go.GetComponent&lt;Renderer&gt;();</span><br><span class="line">                   renderer.sharedMaterial = materials[voxelStructure.voxels[i].palette];</span><br><span class="line">               &#125;</span><br><span class="line">               &#123;</span><br><span class="line">                   var rigidbody = go.AddComponent&lt;Rigidbody&gt;();</span><br><span class="line">                   rigidbody.isKinematic = true;</span><br><span class="line">                   rigidbody.Sleep();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           enabled = false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-触发改变结构体中的一个分离。"><a href="#3-触发改变结构体中的一个分离。" class="headerlink" title="3.触发改变结构体中的一个分离。"></a>3.触发改变结构体中的一个分离。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class TouchRigidbodyExplosion : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">        public float radius = 10f;</span><br><span class="line">        public float power = 500f;</span><br><span class="line"></span><br><span class="line">        void Update()</span><br><span class="line">        &#123;</span><br><span class="line">            bool explosion = false;</span><br><span class="line">            Vector3 position = Vector3.zero;</span><br><span class="line">            if (Input.GetMouseButtonDown(0))</span><br><span class="line">            &#123;</span><br><span class="line">                explosion = true;</span><br><span class="line">                position = Input.mousePosition;</span><br><span class="line">            &#125;</span><br><span class="line">            if (Input.touchCount &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                explosion = true;</span><br><span class="line">                position = Input.GetTouch(0).position;</span><br><span class="line">            &#125;</span><br><span class="line">            if (explosion)</span><br><span class="line">            &#123;</span><br><span class="line">                Ray ray = Camera.main.ScreenPointToRay(position);</span><br><span class="line">                RaycastHit hit;</span><br><span class="line">                if (Physics.Raycast(ray, out hit, 1000))</span><br><span class="line">                &#123;</span><br><span class="line">                    var colliders = Physics.OverlapSphere(hit.point, radius);</span><br><span class="line">                    for (int i = 0; i &lt; colliders.Length; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        var rigidbody = colliders[i].GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">                        if (rigidbody == null) continue;</span><br><span class="line"></span><br><span class="line">                        rigidbody.isKinematic = false;</span><br><span class="line"></span><br><span class="line">                        rigidbody.AddExplosionForce(power, hit.point, radius);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;主要目的，让magical voxel导出的vox 可以一个个像素块的方式推积&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;具体过程&quot;&gt;&lt;a href=&quot;#具体过程&quot; class=&quot;headerlink&quot; title=&quot;具体过程&quot;&gt;&lt;/a&gt;具体过程&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="unity" scheme="www.yqxblog.top/categories/unity/"/>
    
    
      <category term="unity" scheme="www.yqxblog.top/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>unityShader——01</title>
    <link href="www.yqxblog.top/unity/unity_Shader01/"/>
    <id>www.yqxblog.top/unity/unity_Shader01/</id>
    <published>2019-08-30T07:00:00.000Z</published>
    <updated>2019-09-23T15:39:59.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shader-概述"><a href="#Shader-概述" class="headerlink" title="Shader 概述"></a>Shader 概述</h1><h2 id="一、Shader–着色器-运行在图形处理单元，可以让开发人员直接操作图形硬件渲染"><a href="#一、Shader–着色器-运行在图形处理单元，可以让开发人员直接操作图形硬件渲染" class="headerlink" title="一、Shader–着色器 运行在图形处理单元，可以让开发人员直接操作图形硬件渲染"></a>一、Shader–着色器 运行在图形处理单元，可以让开发人员直接操作图形硬件渲染</h2><h3 id="1-Shader能开发出很好的效果，UV动画，水，雾等一些特效。"><a href="#1-Shader能开发出很好的效果，UV动画，水，雾等一些特效。" class="headerlink" title="1.Shader能开发出很好的效果，UV动画，水，雾等一些特效。"></a>1.Shader能开发出很好的效果，UV动画，水，雾等一些特效。</h3><h3 id="2-过程-渲染流水线，模型投影，定点着色"><a href="#2-过程-渲染流水线，模型投影，定点着色" class="headerlink" title="2.过程 渲染流水线，模型投影，定点着色"></a>2.过程 渲染流水线，模型投影，定点着色</h3><h3 id="3-分类为"><a href="#3-分类为" class="headerlink" title="3.分类为"></a>3.分类为</h3><h4 id="顶点Shader-干预模型形态的shader"><a href="#顶点Shader-干预模型形态的shader" class="headerlink" title="顶点Shader 干预模型形态的shader"></a>顶点Shader 干预模型形态的shader</h4><h4 id="像素Shader-干预像素着色的shader"><a href="#像素Shader-干预像素着色的shader" class="headerlink" title="像素Shader 干预像素着色的shader"></a>像素Shader 干预像素着色的shader</h4><h3 id="4-模型顶点运算的时候，可以加入顶点shader来干预顶点的位置；顶点着色的时候，加入像素shader来干预像素的上色；"><a href="#4-模型顶点运算的时候，可以加入顶点shader来干预顶点的位置；顶点着色的时候，加入像素shader来干预像素的上色；" class="headerlink" title="4.模型顶点运算的时候，可以加入顶点shader来干预顶点的位置；顶点着色的时候，加入像素shader来干预像素的上色；"></a>4.模型顶点运算的时候，可以加入顶点shader来干预顶点的位置；顶点着色的时候，加入像素shader来干预像素的上色；</h3><h1 id="GPU编程语言"><a href="#GPU编程语言" class="headerlink" title="GPU编程语言"></a>GPU编程语言</h1><h2 id="1-Direct3D和opengl"><a href="#1-Direct3D和opengl" class="headerlink" title="1. Direct3D和opengl"></a>1. Direct3D和opengl</h2><h3 id="2-分为三种"><a href="#2-分为三种" class="headerlink" title="2.分为三种"></a>2.分为三种</h3><h4 id="1-HLSL语言-只能在Direct3D中使用"><a href="#1-HLSL语言-只能在Direct3D中使用" class="headerlink" title="(1). HLSL语言 -只能在Direct3D中使用"></a>(1). HLSL语言 -只能在Direct3D中使用</h4><h4 id="2-Cg语言-与C相似，都支持"><a href="#2-Cg语言-与C相似，都支持" class="headerlink" title="(2).Cg语言 -与C相似，都支持"></a>(2).Cg语言 -与C相似，都支持</h4><h4 id="3-GLSL语言-只支持opengl"><a href="#3-GLSL语言-只支持opengl" class="headerlink" title="(3).GLSL语言 - 只支持opengl"></a>(3).GLSL语言 - 只支持opengl</h4><h3 id="3-unity使用ShaderLab来进行着色器的编写，对于不同的平台进行编译-重点支持cg语言"><a href="#3-unity使用ShaderLab来进行着色器的编写，对于不同的平台进行编译-重点支持cg语言" class="headerlink" title="3. unity使用ShaderLab来进行着色器的编写，对于不同的平台进行编译 重点支持cg语言"></a>3. unity使用ShaderLab来进行着色器的编写，对于不同的平台进行编译 重点支持cg语言</h3><h1 id="Shader-Lab语法基础"><a href="#Shader-Lab语法基础" class="headerlink" title="Shader Lab语法基础"></a>Shader Lab语法基础</h1><h2 id="1-定义一个Shader"><a href="#1-定义一个Shader" class="headerlink" title="1.定义一个Shader"></a>1.定义一个Shader</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;name&quot;&#123; //name shader名字</span><br><span class="line"> // 定义的一些属性，定义在这里的会在属性查看器里面显示</span><br><span class="line"> [propeties]</span><br><span class="line"> //子着色器列表，一个Shader必须至少有一个子着色器；</span><br><span class="line"> SUbshaders:&#123;....&#125;</span><br><span class="line"> //如果子着色器显卡不支持，就会降级，即Fallback操作；</span><br><span class="line"> [Fallback]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-Properties-定义"><a href="#2-Properties-定义" class="headerlink" title="2.Properties 定义"></a>2.Properties 定义</h2><h3 id="1-name-“displayname”-type-值"><a href="#1-name-“displayname”-type-值" class="headerlink" title="(1). name{“displayname”,type}=值"></a>(1). name{“displayname”,type}=值</h3><ul><li>name：属性的名字，Unity中用下划线开始_Name;</li><li>displayname是指在属性检查器的名字；</li><li>type：这个属性的<strong>类型</strong></li><li><p>值:默认值</p><h3 id="2-类型"><a href="#2-类型" class="headerlink" title="(2).类型"></a>(2).类型</h3><ul><li>FLoat,Int,Color(num,num,num,num)(0~1)Vector(4维向量),Range(start,end)</li><li>2D:2D纹理属性</li><li>Rect：矩形纹理属性</li><li>Cube：立方体纹理属性</li><li>3D：3D纹理属性</li></ul><h3 id="3-name-“displayname”-2D-“name”-options-Options纹理属性选项"><a href="#3-name-“displayname”-2D-“name”-options-Options纹理属性选项" class="headerlink" title="(3). name{“displayname”,2D}= “name”{options} Options纹理属性选项"></a>(3). name{“displayname”,2D}= “name”{options} Options纹理属性选项</h3></li><li><p>TexGen：纹理生成模式，纹理自动生成纹理坐标的模式，顶点shader将会忽略这个选项；</p></li><li>ObjectLinear，EyeLinear，SphereMap，CubeReflect，CubeNormal</li><li>LightmapMod：光照贴图模式如果设置这个选项纹理会被渲染器的光线贴图所影响。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Range&#123;&quot;range value&quot;,Range(0,1)&#125;= 0.3; //定义了一个范围</span><br><span class="line">_Color(&quot;color&quot;,Color)=(1,1,1,1) //定义了一歌颜色</span><br><span class="line">_MainText (&quot;Albedo&quot;,Cube)=&quot;skybox&quot;&#123;TexGen CubeReflect&#125;  //定义一个立方贴图纹理属性；</span><br></pre></td></tr></table></figure><h2 id="3-SubShader"><a href="#3-SubShader" class="headerlink" title="3.SubShader"></a>3.SubShader</h2><h3 id="1-SubShader-Tags-CommonState-Pass"><a href="#1-SubShader-Tags-CommonState-Pass" class="headerlink" title="(1). SubShader{[Tags],[CommonState],Pass{}}"></a>(1). SubShader{[Tags],[CommonState],Pass{}}</h3><p>子着色器由 标签，通用状态，通道了表组成，它定义了一个渲染通道列表，并可选为所有通道初始化许愿哦的通用状态；</p><h3 id="（2-通道类型：RegularPass，UsePass，GrabPass"><a href="#（2-通道类型：RegularPass，UsePass，GrabPass" class="headerlink" title="（2). 通道类型：RegularPass，UsePass，GrabPass"></a>（2). 通道类型：RegularPass，UsePass，GrabPass</h3><p>-一个子着色器有多个通道可以用一个通用状态</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">Tags&#123;&quot;Queue&quot;,&quot;Transparent&quot;&#125;</span><br><span class="line">Pass&#123;</span><br><span class="line">     Lightinig Off  //关闭光照</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/08/30/rhLtA76mZ8COes2.png" alt><br><img src="https://i.loli.net/2019/08/30/9TW3QnkxdpGAMmY.png" alt><br><img src="https://i.loli.net/2019/08/30/W2kCML97hlgZUEG.png" alt><br><img src="https://i.loli.net/2019/08/30/9amSXITAizlRVEK.png" alt><br> <img src="https://i.loli.net/2019/08/30/3oLnT4RMGNrE5pB.png" alt><br> <img src="https://i.loli.net/2019/08/30/DSzXnLqlruORK35.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Shader-概述&quot;&gt;&lt;a href=&quot;#Shader-概述&quot; class=&quot;headerlink&quot; title=&quot;Shader 概述&quot;&gt;&lt;/a&gt;Shader 概述&lt;/h1&gt;&lt;h2 id=&quot;一、Shader–着色器-运行在图形处理单元，可以让开发人员直接操作图形硬
      
    
    </summary>
    
      <category term="unity" scheme="www.yqxblog.top/categories/unity/"/>
    
    
      <category term="unity" scheme="www.yqxblog.top/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>unity摄像机的移动</title>
    <link href="www.yqxblog.top/unity/unity%E6%91%84%E5%83%8F%E6%9C%BA%E7%A7%BB%E5%8A%A8/"/>
    <id>www.yqxblog.top/unity/unity摄像机移动/</id>
    <published>2019-08-30T07:00:00.000Z</published>
    <updated>2019-09-23T15:39:50.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-普通的旋转"><a href="#一、-普通的旋转" class="headerlink" title="一、 普通的旋转"></a>一、 普通的旋转</h1><p> 根据水平和垂直量进行旋转</p><h3 id="第一种是比较简单的版本，"><a href="#第一种是比较简单的版本，" class="headerlink" title="第一种是比较简单的版本，"></a>第一种是比较简单的版本，</h3><p> 得到鼠标现在的位置与之前的位置作比较然后旋转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">newMousePosition = Input.mousePosition;</span><br><span class="line">  hor = (newMousePosition.x - oldMousePosition.x) * sHor;</span><br><span class="line">  vert = (newMousePosition.y - oldMousePosition.y) * sVert;</span><br><span class="line">  print(&quot;hor:&quot;+hor);</span><br><span class="line">  print(&quot;vert:&quot;+ vert);</span><br><span class="line">  //hor = Mathf.Clamp(hor, MinHor, MaxHor);</span><br><span class="line"> // vert = Mathf.Clamp(vert, MinVert, MaxVert);</span><br><span class="line"></span><br><span class="line">  if (newMousePosition != oldMousePosition)</span><br><span class="line">  &#123;</span><br><span class="line">      transform.Rotate(Vector3.up, hor);  // 水平方向旋转</span><br><span class="line">      transform.Rotate(Vector3.right, -1 * vert); //垂直方向旋转</span><br><span class="line">      transform.eulerAngles = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  oldMousePosition = Input.mousePosition;</span><br></pre></td></tr></table></figure></p><h3 id="第二种是略显复杂的版本"><a href="#第二种是略显复杂的版本" class="headerlink" title="第二种是略显复杂的版本"></a>第二种是略显复杂的版本</h3><ul><li>水平旋转：</li><li>垂直旋转：</li><li>水平和垂直旋转：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public enum RotationAxes</span><br><span class="line">      &#123;</span><br><span class="line">             MouseXAndY = 0,</span><br><span class="line">             MouseX=1,</span><br><span class="line">          MouseY=2</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      public float sensitivityHor = 4.5f;</span><br><span class="line">      public float sensitivityVert = 4.5f;</span><br><span class="line"></span><br><span class="line">      public RotationAxes rotation = RotationAxes.MouseXAndY;</span><br><span class="line"></span><br><span class="line">      public  float MinVert = -45.0f;</span><br><span class="line">      public float MaxVert = 45.0f;</span><br><span class="line">      public float MinHorVert = -56f;</span><br><span class="line">      public float MaxHorVert = 55f;</span><br><span class="line"></span><br><span class="line">      public GameObject player;</span><br><span class="line">      private float _RotationX = 0.0f;</span><br><span class="line"></span><br><span class="line">  private Vector3 Dis;</span><br><span class="line">      private void Awake()</span><br><span class="line">      &#123;</span><br><span class="line">           //init 初始时读取数据</span><br><span class="line">      &#125;</span><br><span class="line">      // Use this for initialization</span><br><span class="line">      void Start () &#123;</span><br><span class="line">      Dis = player.transform.position - this.transform.position;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Update is called once per frame</span><br><span class="line">      void Update () &#123;</span><br><span class="line"></span><br><span class="line">          if (rotation == RotationAxes.MouseX)</span><br><span class="line">          &#123;</span><br><span class="line">              this.transform.Rotate(0, Input.GetAxis(&quot;Mouse X&quot;) * sensitivityHor, 0);</span><br><span class="line">          &#125;</span><br><span class="line">          else </span><br><span class="line">              if(rotation == RotationAxes.MouseY)</span><br><span class="line">          &#123;</span><br><span class="line">              _RotationX -= Input.GetAxis(&quot;Mouse Y&quot;) * sensitivityVert;</span><br><span class="line">              _RotationX = Mathf.Clamp(_RotationX, MinVert, MaxVert);</span><br><span class="line">              float RotationY = this.transform.localEulerAngles.y;</span><br><span class="line"></span><br><span class="line">              this.transform.localEulerAngles = new Vector3(_RotationX, RotationY, 0);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      else if (rotation == RotationAxes.MouseXAndY)</span><br><span class="line">      &#123;</span><br><span class="line">              _RotationX -= Input.GetAxis(&quot;Mouse Y&quot;) * sensitivityVert;</span><br><span class="line">              _RotationX = Mathf.Clamp(_RotationX, MinVert, MaxVert);</span><br><span class="line">              float RotationY = this.transform.localEulerAngles.y + Input.GetAxis(&quot;Mouse X&quot;) * sensitivityHor;</span><br><span class="line">               RotationY = CheckAngle(RotationY);</span><br><span class="line">             </span><br><span class="line">              print(RotationY);</span><br><span class="line">              RotationY = Mathf.Clamp(RotationY, MinHorVert, MaxHorVert);</span><br><span class="line">               HeadRotate(_RotationX,RotationY);</span><br><span class="line"></span><br><span class="line">              this.transform.localEulerAngles = new Vector3(_RotationX, RotationY, 0);</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">          &#125;</span><br><span class="line">      MoveWithPlayer();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void MoveWithPlayer()</span><br><span class="line">  &#123;</span><br><span class="line">      this.transform.position = player.transform.position - Dis;</span><br><span class="line">  &#125;</span><br><span class="line">      public void HeadRotate(float hor,float vert)</span><br><span class="line">      &#123;</span><br><span class="line">      // 角色头部旋转</span><br><span class="line">      player.GetComponent&lt;PlayerMove&gt;().HeadeRotate(hor,vert);</span><br><span class="line">         </span><br><span class="line">       &#125;</span><br><span class="line">       public float CheckAngle(float value)  // 将大于180度角进行以负数形式输出</span><br><span class="line">  &#123;</span><br><span class="line">      float angle = value - 180;</span><br><span class="line"></span><br><span class="line">      if (angle &gt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">          return angle - 180;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (value == 0)</span><br><span class="line">      &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return angle + 180;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、-普通的旋转&quot;&gt;&lt;a href=&quot;#一、-普通的旋转&quot; class=&quot;headerlink&quot; title=&quot;一、 普通的旋转&quot;&gt;&lt;/a&gt;一、 普通的旋转&lt;/h1&gt;&lt;p&gt; 根据水平和垂直量进行旋转&lt;/p&gt;
&lt;h3 id=&quot;第一种是比较简单的版本，&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="unity" scheme="www.yqxblog.top/categories/unity/"/>
    
    
      <category term="unity" scheme="www.yqxblog.top/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>unity射线检测</title>
    <link href="www.yqxblog.top/unity/unity%E5%B0%84%E7%BA%BF/"/>
    <id>www.yqxblog.top/unity/unity射线/</id>
    <published>2019-08-02T14:00:00.000Z</published>
    <updated>2019-09-23T15:40:54.213Z</updated>
    
    <content type="html"><![CDATA[<p> Raycastji就是发射一条射线，检测到碰撞体就返回这个碰撞体</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Physics2D.Paycast(Vector2 orign,Vector Direction,float distance,int layerMask);</span><br></pre></td></tr></table></figure><p> 参数解释：</p><p>1、origin：射线投射的原点</p><p>2、direction：射线投射的方向</p><p>3、distance：射线的长度</p><p>4、layerMask：射线只会投射到layerMask层的碰撞体（注意此int参数的写法：1 &lt;&lt; 层数）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; Raycastji就是发射一条射线，检测到碰撞体就返回这个碰撞体&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="unity" scheme="www.yqxblog.top/categories/unity/"/>
    
    
      <category term="unity" scheme="www.yqxblog.top/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>unity的屏幕设置</title>
    <link href="www.yqxblog.top/unity/unity_03/"/>
    <id>www.yqxblog.top/unity/unity_03/</id>
    <published>2019-08-02T14:00:00.000Z</published>
    <updated>2019-09-23T15:41:05.281Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class groy : MonoBehaviour &#123;</span><br><span class="line">void Awake()</span><br><span class="line">        &#123;</span><br><span class="line">                //设置屏幕正方向在Home键右边</span><br><span class="line">                Screen.orientation = ScreenOrientation.LandscapeRight;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        void Start () </span><br><span class="line">        &#123;</span><br><span class="line">                //设置屏幕自动旋转， 并置支持的方向</span><br><span class="line">                Screen.orientation = ScreenOrientation.AutoRotation;</span><br><span class="line">                Screen.autorotateToLandscapeLeft = true;</span><br><span class="line">                Screen.autorotateToLandscapeRight = true;</span><br><span class="line">                Screen.autorotateToPortrait = false;</span><br><span class="line">                Screen.autorotateToPortraitUpsideDown = false;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="unity" scheme="www.yqxblog.top/categories/unity/"/>
    
    
      <category term="unity" scheme="www.yqxblog.top/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之行为型</title>
    <link href="www.yqxblog.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    <id>www.yqxblog.top/设计模式/设计模式之行为型/</id>
    <published>2019-06-13T00:43:11.000Z</published>
    <updated>2019-06-14T04:34:34.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何谓行为型模式"><a href="#何谓行为型模式" class="headerlink" title="何谓行为型模式"></a>何谓行为型模式</h2><p> <strong>行为型模式为设计模式的一种类型，用来识别对象之间的常用交流模式并加以实现。如此，可在进行这些交流活动时增强弹性。</strong></p><ul><li>观察者模式</li><li>模板方法模式</li><li>命令方法模式</li><li>状态模式</li><li>职责链模式</li><li>解释器模式</li><li>中介者模式</li><li>访问者模式</li><li>策略模式</li><li>备忘录模式</li><li>迭代器模式</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;何谓行为型模式&quot;&gt;&lt;a href=&quot;#何谓行为型模式&quot; class=&quot;headerlink&quot; title=&quot;何谓行为型模式&quot;&gt;&lt;/a&gt;何谓行为型模式&lt;/h2&gt;&lt;p&gt; &lt;strong&gt;行为型模式为设计模式的一种类型，用来识别对象之间的常用交流模式并加以实现。如此，可
      
    
    </summary>
    
      <category term="设计模式" scheme="www.yqxblog.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="www.yqxblog.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之结构型</title>
    <link href="www.yqxblog.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    <id>www.yqxblog.top/设计模式/设计模式之结构型/</id>
    <published>2019-06-12T06:00:00.000Z</published>
    <updated>2019-06-14T04:34:37.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何谓结构型设计模式"><a href="#何谓结构型设计模式" class="headerlink" title="何谓结构型设计模式"></a>何谓结构型设计模式</h2><p><strong>借由一以贯之的方式来了解元件间的关系，以简化设计。</strong></p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><ul><li>适配器模式：将一个物体的界面‘转接’成当事人预期的样子</li><li>桥接模式：将一个抽象与实现解耦，以便两者可以独立的变化。组合模式：树状结构的物件，每个物件有相同的界面</li><li>装饰模式：对一个执行的类别，若使用继承方式加上新功能可能会新类别的数量呈指数型地增加，可使用此模式来解决。、</li><li>组合模式：树状结构的物件，每个物件有相同的界面</li><li>外观模式：对于已有的界面建立一个简化的界面以简化使用共通任务。</li><li>享元模式：通过共享以便有效的支持大量小颗粒对象。</li><li><p>代理模式：为其他对象提供一个代理以控制对这个对象的访问。</p><blockquote><p>在我看来，结构型模式就是在不增加类的高内聚低耦合的情况利用继承，聚合，包含，将一个类的功能延伸或减少某个类的复杂性，</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;何谓结构型设计模式&quot;&gt;&lt;a href=&quot;#何谓结构型设计模式&quot; class=&quot;headerlink&quot; title=&quot;何谓结构型设计模式&quot;&gt;&lt;/a&gt;何谓结构型设计模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;借由一以贯之的方式来了解元件间的关系，以简化设计。&lt;/strong&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="www.yqxblog.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="www.yqxblog.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之创建型</title>
    <link href="www.yqxblog.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    <id>www.yqxblog.top/设计模式/设计模式之创建型/</id>
    <published>2019-06-11T13:00:00.000Z</published>
    <updated>2019-06-12T12:43:13.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何谓创建型模式"><a href="#何谓创建型模式" class="headerlink" title="何谓创建型模式?"></a>何谓创建型模式?</h2><p><strong>创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。创建型模式通过以某种方式控制对象的创建来解决问题。</strong></p><h5 id="1-创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。"><a href="#1-创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。" class="headerlink" title="1.创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。"></a>1.创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。</h5><h5 id="2-创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。"><a href="#2-创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。" class="headerlink" title="2.创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。"></a>2.创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。</h5><h3 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h3><p><strong>目的：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>举例：</strong><br>　　在OS中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。<br> <img src="https://i.loli.net/2019/06/12/5d00ef8b776e039846.png" alt><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package 单例模式;</span><br><span class="line"></span><br><span class="line">public class Singleton &#123;</span><br><span class="line">private static Singleton instance;</span><br><span class="line">Singleton() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public Singleton GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">if(instance == null)</span><br><span class="line">&#123;</span><br><span class="line">instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">package 单例模式;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">  public static void main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">  Singleton singleton = new Singleton();</span><br><span class="line">  Singleton s1 = singleton.GetInstance();</span><br><span class="line">  Singleton s2 = singleton.GetInstance();</span><br><span class="line">  Singleton s3 = new Singleton();</span><br><span class="line">  if(s1==s2)System.out.println(&quot;s1==s2&quot;);</span><br><span class="line">  if(s1==s3)System.out.println(&quot;s1==s3&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result: s1==s2</span><br></pre></td></tr></table></figure></p><h3 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h3><p><strong>原理:</strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//实例基类，相当于Product(为了方便，没用抽象)</span><br><span class="line">class LeiFeng</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Sweep()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;雷锋扫地&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//学雷锋的大学生，相当于ConcreteProduct（具体产品1）</span><br><span class="line">class Student: public LeiFeng</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Sweep()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;大学生扫地&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//学雷锋的志愿者，相当于ConcreteProduct（具体产品2）</span><br><span class="line">class Volenter: public LeiFeng</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    virtual void Sweep()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;志愿者&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">//工场基类Creator</span><br><span class="line">class LeiFengFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual LeiFeng* CreateLeiFeng() //返回值体现依赖关系</span><br><span class="line">    &#123;</span><br><span class="line">        return new LeiFeng();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//工场具体类1（创建大学生产品的具体工厂）</span><br><span class="line">class StudentFactory : public LeiFengFactory</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    virtual LeiFeng* CreateLeiFeng() //返回值体现依赖关系</span><br><span class="line">    &#123;</span><br><span class="line">        return new Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//工场具体类2（创建志愿者产品的具体工厂）</span><br><span class="line">class VolenterFactory : public LeiFengFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual LeiFeng* CreateLeiFeng()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Volenter(); //返回值体现依赖关系</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">//客户端</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LeiFengFactory *sf=new StudentFactory(); //由客户端选创建什么产品</span><br><span class="line">    LeiFeng *s=sf-&gt;CreateLeiFeng();</span><br><span class="line">    s-&gt;Sweep();</span><br><span class="line">    delete s;</span><br><span class="line">    delete sf;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><p><strong>功能：</strong>提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类。<br><strong>优缺点：</strong>遵循高内聚低耦合的设计目的，但无法避免开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦，或反之）<br><strong>模式应用：</strong><br>　在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。</p><p><img src="https://i.loli.net/2019/06/12/5d00f0bdba47d87017.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//用户抽象接口(抽象产品A)</span><br><span class="line">class IUser</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    virtual void GetUser()=0;</span><br><span class="line">    virtual void InsertUser()=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//部门抽象接口(抽象产品B)</span><br><span class="line">class IDepartment</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetDepartment()=0;</span><br><span class="line">    virtual void InsertDepartment()=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ACCESS用户（抽象产品A的产品1）</span><br><span class="line">class CAccessUser : public IUser</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetUser()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Access GetUser&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void InsertUser()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Access InsertUser&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ACCESS部门（抽象产品B的产品1）</span><br><span class="line">class CAccessDepartment : public IDepartment</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Access GetDepartment&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void InsertDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Access InsertDepartment&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//SQL用户（抽象产品A的产品2）</span><br><span class="line">class CSqlUser : public IUser</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetUser()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Sql User&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void InsertUser()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Sql User&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//SQL部门类（抽象产品B的产品2）</span><br><span class="line">class CSqlDepartment: public IDepartment</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;sql getDepartment&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void InsertDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;sql insertdepartment&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象工厂</span><br><span class="line">class IFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual IUser* CreateUser()=0;</span><br><span class="line">    virtual IDepartment* CreateDepartment()=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ACCESS工厂</span><br><span class="line">class AccessFactory : public IFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual IUser* CreateUser()</span><br><span class="line">    &#123;</span><br><span class="line">        return new  CAccessUser();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual IDepartment* CreateDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        return new CAccessDepartment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//SQL工厂</span><br><span class="line">class SqlFactory : public IFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual IUser* CreateUser()</span><br><span class="line">    &#123;</span><br><span class="line">        return new  CSqlUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual IDepartment* CreateDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        return new CSqlDepartment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//客户端：</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    IFactory* factory= new SqlFactory();</span><br><span class="line">    IUser* user=factory-&gt;CreateUser();</span><br><span class="line">    IDepartment* depart = factory-&gt;CreateDepartment();</span><br><span class="line"></span><br><span class="line">    user-&gt;GetUser();</span><br><span class="line">    depart-&gt;GetDepartment();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、建造者模式"><a href="#四、建造者模式" class="headerlink" title="四、建造者模式"></a>四、建造者模式</h3><p><strong>功能：</strong>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。<br><strong>优缺点：</strong>一个指挥控制全部，可以精细的控制产品的创建过程，系统扩展方便，符合“开闭”。但产品越多越复杂，内部变多，会导致系统变复杂<br><strong>模式应用：</strong><br>很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。<br><img src="https://i.loli.net/2019/06/12/5d00f251503d917985.png" alt><br><strong>举例：</strong> KFC套餐<br>套餐是一个复杂对象，一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、 可乐等）等部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。<br><img src="https://i.loli.net/2019/06/12/5d00f287de42455379.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//最终的产品类</span><br><span class="line">class Product </span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; m_product;</span><br><span class="line">public:</span><br><span class="line">    void Add(string strtemp)</span><br><span class="line">    &#123;</span><br><span class="line">        m_product.push_back(strtemp);</span><br><span class="line">    &#125;</span><br><span class="line">    void Show()</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt;::iterator p=m_product.begin();</span><br><span class="line">        while (p!=m_product.end())</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//建造者基类</span><br><span class="line">class Builder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void BuilderA()=0;</span><br><span class="line">    virtual void BuilderB()=0;</span><br><span class="line">    virtual Product* GetResult()=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//第一种建造方式</span><br><span class="line">class ConcreteBuilder1 : public Builder</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    Product* m_product; //体现依赖关系</span><br><span class="line">public:</span><br><span class="line">    ConcreteBuilder1()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product=new Product();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void BuilderA()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product-&gt;Add(&quot;one&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void BuilderB()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product-&gt;Add(&quot;two&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual Product* GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//第二种建造方式</span><br><span class="line">class ConcreteBuilder2 : public Builder</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    Product * m_product;  //体现依赖关系</span><br><span class="line">public:</span><br><span class="line">    ConcreteBuilder2()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product=new Product();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void BuilderA()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product-&gt;Add(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void BuilderB()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product-&gt;Add(&quot;B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual Product* GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//指挥者类</span><br><span class="line">class Direct</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Construct(Builder* temp) //构建一个使用Builder接口的对象</span><br><span class="line">    &#123;</span><br><span class="line">        temp-&gt;BuilderA();</span><br><span class="line">        temp-&gt;BuilderB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//客户端</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Direct *p=new Direct();</span><br><span class="line">    Builder* b1=new ConcreteBuilder1();</span><br><span class="line">    Builder* b2=new ConcreteBuilder2();</span><br><span class="line"></span><br><span class="line">    p-&gt;Construct(b1);                 //调用第一种建造方式</span><br><span class="line">    Product* pb1 = b1-&gt;GetResult();</span><br><span class="line">    pb1-&gt;Show();</span><br><span class="line"></span><br><span class="line">    p-&gt;Construct(b2);                 //调用第二种建造方式</span><br><span class="line">    Product * pb2 = b2-&gt;GetResult();</span><br><span class="line">    pb2-&gt;Show();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="五、原型模式"><a href="#五、原型模式" class="headerlink" title="五、原型模式"></a>五、原型模式</h3><p><strong>功能：</strong>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象创建另外一个可定制的对象，而且不需知道任何创建的细节。</p><blockquote><p>java java.lang.Cloneable 接口<br>c# ICloneable 接口</p></blockquote><p><img src="https://i.loli.net/2019/06/12/5d00f2e2e850613476.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//抽象基类</span><br><span class="line">class Prototype  </span><br><span class="line">&#123; </span><br><span class="line">private:</span><br><span class="line">    string m_strName;</span><br><span class="line"></span><br><span class="line">public: </span><br><span class="line">    Prototype(string strName)&#123; m_strName = strName; &#125;</span><br><span class="line">    Prototype() &#123; m_strName = &quot; &quot;; &#125;</span><br><span class="line">    void Show() </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;m_strName&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual Prototype* Clone() = 0 ; //关键就在于这样一个抽象方法</span><br><span class="line">&#125; ; </span><br><span class="line"></span><br><span class="line">// class ConcretePrototype1 </span><br><span class="line">class ConcretePrototype1 : public Prototype </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line">    ConcretePrototype1(string strName) : Prototype(strName)&#123;&#125;</span><br><span class="line">    ConcretePrototype1()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual Prototype* Clone() </span><br><span class="line">    &#123; </span><br><span class="line">        ConcretePrototype1 *p = new ConcretePrototype1() ; </span><br><span class="line">        *p = *this ;                         //复制对象 </span><br><span class="line">        return p ; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; ; </span><br><span class="line"></span><br><span class="line">// class ConcretePrototype2 </span><br><span class="line">class ConcretePrototype2 : public Prototype </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line">    ConcretePrototype2(string strName) : Prototype(strName)&#123;&#125;</span><br><span class="line">    ConcretePrototype2()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual Prototype* Clone() </span><br><span class="line">    &#123; </span><br><span class="line">        ConcretePrototype2 *p = new ConcretePrototype2() ; </span><br><span class="line">        *p = *this ; //复制对象 </span><br><span class="line">        return p ; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; ; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//客户端</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ConcretePrototype1* test = new ConcretePrototype1(&quot;小王&quot;);</span><br><span class="line">    ConcretePrototype2* test2 = (ConcretePrototype2*)test-&gt;Clone();</span><br><span class="line">    test-&gt;Show();</span><br><span class="line">    test2-&gt;Show();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;何谓创建型模式&quot;&gt;&lt;a href=&quot;#何谓创建型模式&quot; class=&quot;headerlink&quot; title=&quot;何谓创建型模式?&quot;&gt;&lt;/a&gt;何谓创建型模式?&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。创建
      
    
    </summary>
    
      <category term="设计模式" scheme="www.yqxblog.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="www.yqxblog.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之创建型</title>
    <link href="www.yqxblog.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93_1/"/>
    <id>www.yqxblog.top/设计模式/设计模式总结_1/</id>
    <published>2019-06-11T13:00:00.000Z</published>
    <updated>2019-06-14T04:31:59.052Z</updated>
    
    <content type="html"><![CDATA[<p>有三个原则：单一职责，开放封闭，依赖倒转。</p><h2 id="何谓创建型模式"><a href="#何谓创建型模式" class="headerlink" title="何谓创建型模式?"></a>何谓创建型模式?</h2><p><strong>创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。创建型模式通过以某种方式控制对象的创建来解决问题。</strong></p><h5 id="1-创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。"><a href="#1-创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。" class="headerlink" title="1.创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。"></a>1.创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。</h5><h5 id="2-创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。"><a href="#2-创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。" class="headerlink" title="2.创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。"></a>2.创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。</h5><h3 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h3><p><strong>目的：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>举例：</strong><br>　　在OS中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。<br> <img src="https://i.loli.net/2019/06/12/5d00ef8b776e039846.png" alt><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package 单例模式;</span><br><span class="line"></span><br><span class="line">public class Singleton &#123;</span><br><span class="line">private static Singleton instance;</span><br><span class="line">Singleton() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public Singleton GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">if(instance == null)</span><br><span class="line">&#123;</span><br><span class="line">instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">package 单例模式;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">  public static void main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">  Singleton singleton = new Singleton();</span><br><span class="line">  Singleton s1 = singleton.GetInstance();</span><br><span class="line">  Singleton s2 = singleton.GetInstance();</span><br><span class="line">  Singleton s3 = new Singleton();</span><br><span class="line">  if(s1==s2)System.out.println(&quot;s1==s2&quot;);</span><br><span class="line">  if(s1==s3)System.out.println(&quot;s1==s3&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result: s1==s2</span><br></pre></td></tr></table></figure></p><h3 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h3><p><strong>原理:</strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//实例基类，相当于Product(为了方便，没用抽象)</span><br><span class="line">class LeiFeng</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Sweep()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;雷锋扫地&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//学雷锋的大学生，相当于ConcreteProduct（具体产品1）</span><br><span class="line">class Student: public LeiFeng</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Sweep()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;大学生扫地&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//学雷锋的志愿者，相当于ConcreteProduct（具体产品2）</span><br><span class="line">class Volenter: public LeiFeng</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    virtual void Sweep()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;志愿者&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">//工场基类Creator</span><br><span class="line">class LeiFengFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual LeiFeng* CreateLeiFeng() //返回值体现依赖关系</span><br><span class="line">    &#123;</span><br><span class="line">        return new LeiFeng();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//工场具体类1（创建大学生产品的具体工厂）</span><br><span class="line">class StudentFactory : public LeiFengFactory</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    virtual LeiFeng* CreateLeiFeng() //返回值体现依赖关系</span><br><span class="line">    &#123;</span><br><span class="line">        return new Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//工场具体类2（创建志愿者产品的具体工厂）</span><br><span class="line">class VolenterFactory : public LeiFengFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual LeiFeng* CreateLeiFeng()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Volenter(); //返回值体现依赖关系</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">-----------------------------</span><br><span class="line">//客户端</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LeiFengFactory *sf=new StudentFactory(); //由客户端选创建什么产品</span><br><span class="line">    LeiFeng *s=sf-&gt;CreateLeiFeng();</span><br><span class="line">    s-&gt;Sweep();</span><br><span class="line">    delete s;</span><br><span class="line">    delete sf;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><p><strong>功能：</strong>提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类。<br><strong>优缺点：</strong>遵循高内聚低耦合的设计目的，但无法避免开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦，或反之）<br><strong>模式应用：</strong><br>　在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。</p><p><img src="https://i.loli.net/2019/06/12/5d00f0bdba47d87017.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//用户抽象接口(抽象产品A)</span><br><span class="line">class IUser</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    virtual void GetUser()=0;</span><br><span class="line">    virtual void InsertUser()=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//部门抽象接口(抽象产品B)</span><br><span class="line">class IDepartment</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetDepartment()=0;</span><br><span class="line">    virtual void InsertDepartment()=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ACCESS用户（抽象产品A的产品1）</span><br><span class="line">class CAccessUser : public IUser</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetUser()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Access GetUser&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void InsertUser()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Access InsertUser&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ACCESS部门（抽象产品B的产品1）</span><br><span class="line">class CAccessDepartment : public IDepartment</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Access GetDepartment&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void InsertDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Access InsertDepartment&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//SQL用户（抽象产品A的产品2）</span><br><span class="line">class CSqlUser : public IUser</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetUser()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Sql User&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void InsertUser()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;Sql User&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//SQL部门类（抽象产品B的产品2）</span><br><span class="line">class CSqlDepartment: public IDepartment</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void GetDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;sql getDepartment&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void InsertDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;sql insertdepartment&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象工厂</span><br><span class="line">class IFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual IUser* CreateUser()=0;</span><br><span class="line">    virtual IDepartment* CreateDepartment()=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ACCESS工厂</span><br><span class="line">class AccessFactory : public IFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual IUser* CreateUser()</span><br><span class="line">    &#123;</span><br><span class="line">        return new  CAccessUser();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual IDepartment* CreateDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        return new CAccessDepartment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//SQL工厂</span><br><span class="line">class SqlFactory : public IFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual IUser* CreateUser()</span><br><span class="line">    &#123;</span><br><span class="line">        return new  CSqlUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual IDepartment* CreateDepartment()</span><br><span class="line">    &#123;</span><br><span class="line">        return new CSqlDepartment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//客户端：</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    IFactory* factory= new SqlFactory();</span><br><span class="line">    IUser* user=factory-&gt;CreateUser();</span><br><span class="line">    IDepartment* depart = factory-&gt;CreateDepartment();</span><br><span class="line"></span><br><span class="line">    user-&gt;GetUser();</span><br><span class="line">    depart-&gt;GetDepartment();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、建造者模式"><a href="#四、建造者模式" class="headerlink" title="四、建造者模式"></a>四、建造者模式</h3><p><strong>功能：</strong>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。<br><strong>优缺点：</strong>一个指挥控制全部，可以精细的控制产品的创建过程，系统扩展方便，符合“开闭”。但产品越多越复杂，内部变多，会导致系统变复杂<br><strong>模式应用：</strong><br>很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。<br><img src="https://i.loli.net/2019/06/12/5d00f251503d917985.png" alt><br><strong>举例：</strong> KFC套餐<br>套餐是一个复杂对象，一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、 可乐等）等部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。<br><img src="https://i.loli.net/2019/06/12/5d00f287de42455379.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//最终的产品类</span><br><span class="line">class Product </span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; m_product;</span><br><span class="line">public:</span><br><span class="line">    void Add(string strtemp)</span><br><span class="line">    &#123;</span><br><span class="line">        m_product.push_back(strtemp);</span><br><span class="line">    &#125;</span><br><span class="line">    void Show()</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt;::iterator p=m_product.begin();</span><br><span class="line">        while (p!=m_product.end())</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//建造者基类</span><br><span class="line">class Builder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void BuilderA()=0;</span><br><span class="line">    virtual void BuilderB()=0;</span><br><span class="line">    virtual Product* GetResult()=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//第一种建造方式</span><br><span class="line">class ConcreteBuilder1 : public Builder</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    Product* m_product; //体现依赖关系</span><br><span class="line">public:</span><br><span class="line">    ConcreteBuilder1()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product=new Product();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void BuilderA()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product-&gt;Add(&quot;one&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void BuilderB()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product-&gt;Add(&quot;two&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual Product* GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//第二种建造方式</span><br><span class="line">class ConcreteBuilder2 : public Builder</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    Product * m_product;  //体现依赖关系</span><br><span class="line">public:</span><br><span class="line">    ConcreteBuilder2()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product=new Product();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void BuilderA()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product-&gt;Add(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void BuilderB()</span><br><span class="line">    &#123;</span><br><span class="line">        m_product-&gt;Add(&quot;B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual Product* GetResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//指挥者类</span><br><span class="line">class Direct</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Construct(Builder* temp) //构建一个使用Builder接口的对象</span><br><span class="line">    &#123;</span><br><span class="line">        temp-&gt;BuilderA();</span><br><span class="line">        temp-&gt;BuilderB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//客户端</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Direct *p=new Direct();</span><br><span class="line">    Builder* b1=new ConcreteBuilder1();</span><br><span class="line">    Builder* b2=new ConcreteBuilder2();</span><br><span class="line"></span><br><span class="line">    p-&gt;Construct(b1);                 //调用第一种建造方式</span><br><span class="line">    Product* pb1 = b1-&gt;GetResult();</span><br><span class="line">    pb1-&gt;Show();</span><br><span class="line"></span><br><span class="line">    p-&gt;Construct(b2);                 //调用第二种建造方式</span><br><span class="line">    Product * pb2 = b2-&gt;GetResult();</span><br><span class="line">    pb2-&gt;Show();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="五、原型模式"><a href="#五、原型模式" class="headerlink" title="五、原型模式"></a>五、原型模式</h3><p><strong>功能：</strong>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象创建另外一个可定制的对象，而且不需知道任何创建的细节。</p><blockquote><p>java java.lang.Cloneable 接口<br>c# ICloneable 接口</p></blockquote><p><img src="https://i.loli.net/2019/06/12/5d00f2e2e850613476.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//抽象基类</span><br><span class="line">class Prototype  </span><br><span class="line">&#123; </span><br><span class="line">private:</span><br><span class="line">    string m_strName;</span><br><span class="line"></span><br><span class="line">public: </span><br><span class="line">    Prototype(string strName)&#123; m_strName = strName; &#125;</span><br><span class="line">    Prototype() &#123; m_strName = &quot; &quot;; &#125;</span><br><span class="line">    void Show() </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;m_strName&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual Prototype* Clone() = 0 ; //关键就在于这样一个抽象方法</span><br><span class="line">&#125; ; </span><br><span class="line"></span><br><span class="line">// class ConcretePrototype1 </span><br><span class="line">class ConcretePrototype1 : public Prototype </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line">    ConcretePrototype1(string strName) : Prototype(strName)&#123;&#125;</span><br><span class="line">    ConcretePrototype1()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual Prototype* Clone() </span><br><span class="line">    &#123; </span><br><span class="line">        ConcretePrototype1 *p = new ConcretePrototype1() ; </span><br><span class="line">        *p = *this ;                         //复制对象 </span><br><span class="line">        return p ; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; ; </span><br><span class="line"></span><br><span class="line">// class ConcretePrototype2 </span><br><span class="line">class ConcretePrototype2 : public Prototype </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line">    ConcretePrototype2(string strName) : Prototype(strName)&#123;&#125;</span><br><span class="line">    ConcretePrototype2()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual Prototype* Clone() </span><br><span class="line">    &#123; </span><br><span class="line">        ConcretePrototype2 *p = new ConcretePrototype2() ; </span><br><span class="line">        *p = *this ; //复制对象 </span><br><span class="line">        return p ; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; ; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//客户端</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ConcretePrototype1* test = new ConcretePrototype1(&quot;小王&quot;);</span><br><span class="line">    ConcretePrototype2* test2 = (ConcretePrototype2*)test-&gt;Clone();</span><br><span class="line">    test-&gt;Show();</span><br><span class="line">    test2-&gt;Show();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有三个原则：单一职责，开放封闭，依赖倒转。&lt;/p&gt;
&lt;h2 id=&quot;何谓创建型模式&quot;&gt;&lt;a href=&quot;#何谓创建型模式&quot; class=&quot;headerlink&quot; title=&quot;何谓创建型模式?&quot;&gt;&lt;/a&gt;何谓创建型模式?&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;创建型模式是处理对象创
      
    
    </summary>
    
      <category term="设计模式" scheme="www.yqxblog.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="www.yqxblog.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式实践_FPS游戏</title>
    <link href="www.yqxblog.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E8%B7%B5FPS%E6%B8%B8%E6%88%8F/"/>
    <id>www.yqxblog.top/设计模式/设计模式实践FPS游戏/</id>
    <published>2019-06-11T02:30:00.000Z</published>
    <updated>2019-06-12T12:43:19.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、地图切换；-–抽象工厂模式"><a href="#一、地图切换；-–抽象工厂模式" class="headerlink" title="一、地图切换；   –抽象工厂模式"></a>一、地图切换；   –抽象工厂模式</h3><p>每个地图是一个工厂，每个地图中的不同场景，敌人等等的是一个个的产品</p><p>人物移动；<br>人物状态：生存/死亡    – 状态模式 </p><h3 id="二、服装设计；-—建造者模式"><a href="#二、服装设计；-—建造者模式" class="headerlink" title="二、服装设计；  —建造者模式"></a>二、服装设计；  —建造者模式</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、地图切换；-–抽象工厂模式&quot;&gt;&lt;a href=&quot;#一、地图切换；-–抽象工厂模式&quot; class=&quot;headerlink&quot; title=&quot;一、地图切换；   –抽象工厂模式&quot;&gt;&lt;/a&gt;一、地图切换；   –抽象工厂模式&lt;/h3&gt;&lt;p&gt;每个地图是一个工厂，每个地图
      
    
    </summary>
    
      <category term="设计模式" scheme="www.yqxblog.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="www.yqxblog.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（插入、）</title>
    <link href="www.yqxblog.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>www.yqxblog.top/数据结构/数据结构-排序算法/</id>
    <published>2019-06-11T00:43:11.000Z</published>
    <updated>2019-06-12T07:59:06.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、插入排序"><a href="#一、插入排序" class="headerlink" title="一、插入排序"></a>一、插入排序</h3><h4 id="1-是一种简单直观且稳定的排序算法。"><a href="#1-是一种简单直观且稳定的排序算法。" class="headerlink" title="1.是一种简单直观且稳定的排序算法。"></a>1.是一种简单直观且稳定的排序算法。</h4><h4 id="2-原理：将每个序列分为有序序列和无序序列，每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。"><a href="#2-原理：将每个序列分为有序序列和无序序列，每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。" class="headerlink" title="2.原理：将每个序列分为有序序列和无序序列，每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。"></a>2.原理：将每个序列分为有序序列和无序序列，每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。</h4><h4 id="3-时间复杂度为O-n2"><a href="#3-时间复杂度为O-n2" class="headerlink" title="3.时间复杂度为O(n2)"></a>3.时间复杂度为<strong>O(n<sup>2</sup>)</strong></h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> void InsertSort(int r[],int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(int i=2 ;i&lt;n;i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        int j;</span><br><span class="line">        r[0]=r[i];     //目前无序序列的第一个数据放到r[0]</span><br><span class="line">        for(j=i-1;r[0]&lt;r[j];j--)  //从r[1]这个序列开始排序，r[0]挨个从有序序列的最后一个往前一个个比较</span><br><span class="line">        r[j+1]=r[j];</span><br><span class="line">        r[j+1] = r[0];   //比较完了，将目标数据插入到有序序列相应位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"> int a[11] = &#123;0,4,1,5,6,3,2,8,7,9,10&#125;;</span><br><span class="line">    InsertSort(a,11);</span><br><span class="line">    for(int i =1 ;i &lt; 11;i++)</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://i.loli.net/2019/06/11/5cfefbfbbf55d37847.png" alt></p><h3 id="二、希尔排序"><a href="#二、希尔排序" class="headerlink" title="二、希尔排序"></a>二、希尔排序</h3><h4 id="1-希尔排序-Shell’s-Sort-是插入排序的一种又称“缩小增量排序”（Diminishing-Increment-Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D-L-Shell于1959年提出而得名。"><a href="#1-希尔排序-Shell’s-Sort-是插入排序的一种又称“缩小增量排序”（Diminishing-Increment-Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D-L-Shell于1959年提出而得名。" class="headerlink" title="1.希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。"></a>1.希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。</h4><h4 id="2-是对插入排序的改进，在插入排序中是以1为增量让有序序列的第一个值挨个和有序序列的进行比较希尔排序额中是以d为增，d慢慢减小到1，这个过程中不断让每一次排序的所用的比较次数减少。"><a href="#2-是对插入排序的改进，在插入排序中是以1为增量让有序序列的第一个值挨个和有序序列的进行比较希尔排序额中是以d为增，d慢慢减小到1，这个过程中不断让每一次排序的所用的比较次数减少。" class="headerlink" title="2.是对插入排序的改进，在插入排序中是以1为增量让有序序列的第一个值挨个和有序序列的进行比较希尔排序额中是以d为增，d慢慢减小到1，这个过程中不断让每一次排序的所用的比较次数减少。"></a>2.是对插入排序的改进，在插入排序中是以1为增量让有序序列的第一个值挨个和有序序列的进行比较希尔排序额中是以d为增，d慢慢减小到1，这个过程中不断让每一次排序的所用的比较次数减少。</h4><h4 id="3-希尔排序是对直接插入排序的一种优化，可以用于大型的数组，希尔排序比插入排序和选择排序要快的多，并且数组越大，优势越大。"><a href="#3-希尔排序是对直接插入排序的一种优化，可以用于大型的数组，希尔排序比插入排序和选择排序要快的多，并且数组越大，优势越大。" class="headerlink" title="3.希尔排序是对直接插入排序的一种优化，可以用于大型的数组，希尔排序比插入排序和选择排序要快的多，并且数组越大，优势越大。"></a>3.希尔排序是对直接插入排序的一种优化，可以用于大型的数组，希尔排序比插入排序和选择排序要快的多，并且数组越大，优势越大。</h4><h4 id="4-时间复杂度-：O-n1-3"><a href="#4-时间复杂度-：O-n1-3" class="headerlink" title="4.时间复杂度 ：O(n1.3)"></a>4.时间复杂度 ：O(n<sup>1.3</sup>)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void HillSort(int r[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(int d=n/2 ; d&gt;=1; d=d/2)   //以d位增量来插入</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for(i=d+1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            r[0]=r[i];</span><br><span class="line">            for(j=i-d;j&gt;0&amp;&amp;r[0]&lt;r[j];j-=d)</span><br><span class="line">            &#123;</span><br><span class="line">                r[j+d]=r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            r[j+d]=r[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line"> int a[11] = &#123;0,4,1,5,6,3,2,8,7,9,10&#125;;</span><br><span class="line">    HillSort(a,11);</span><br><span class="line">    for(int i =1 ;i &lt; 11;i++)</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/11/5cfeffef648f129548.png" alt></p><h3 id="三、冒泡排序（双向排序）-双向冒泡排序"><a href="#三、冒泡排序（双向排序）-双向冒泡排序" class="headerlink" title="三、冒泡排序（双向排序）+ 双向冒泡排序"></a>三、冒泡排序（双向排序）+ 双向冒泡排序</h3><blockquote><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p></blockquote><h4 id="冒泡排序算法的原理如下："><a href="#冒泡排序算法的原理如下：" class="headerlink" title="冒泡排序算法的原理如下："></a>冒泡排序算法的原理如下：</h4><h4 id="1-比较相邻的元素。如果第一个比第二个大，就交换他们两个。"><a href="#1-比较相邻的元素。如果第一个比第二个大，就交换他们两个。" class="headerlink" title="1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。"></a>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。</h4><h4 id="2-对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。"><a href="#2-对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。" class="headerlink" title="2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。"></a>2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</h4><h4 id="3-针对所有的元素重复以上的步骤，除了最后一个。"><a href="#3-针对所有的元素重复以上的步骤，除了最后一个。" class="headerlink" title="3.针对所有的元素重复以上的步骤，除了最后一个。"></a>3.针对所有的元素重复以上的步骤，除了最后一个。</h4><h4 id="4-持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。"><a href="#4-持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。" class="headerlink" title="4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。"></a>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</h4><h4 id="3-时间复杂度O-n²"><a href="#3-时间复杂度O-n²" class="headerlink" title="3.时间复杂度O(n²)"></a>3.时间复杂度O(n²)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">void BubbleSort(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int bound;</span><br><span class="line">    int exchange = n;  //有序序列第一个值为最后一个值</span><br><span class="line">    while(exchange!=0)</span><br><span class="line">    &#123;</span><br><span class="line">       bound =  exchange ;   //有序序列第一个值</span><br><span class="line">       exchange  = 0;     //exchange=0 如果下面的循环中的判断成立，也就是无序序列确实是无序，则while循环继续。</span><br><span class="line">       for(int i =0 ;i&lt;bound;i++)</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           if(a[i]&gt;a[i+1])</span><br><span class="line">           &#123;</span><br><span class="line">               int temp = a[i];</span><br><span class="line">               a[i] = a[i+1];</span><br><span class="line">               a[i+1] = temp;</span><br><span class="line">               exchange = i ;  //for循环截至是，exchange就是有序序列的第一个值</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DoubleBubbleSort(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">  int low = 0,high;</span><br><span class="line">  high =n-1;</span><br><span class="line">  int lastPos;</span><br><span class="line">  while(low&lt;high)</span><br><span class="line">  &#123;</span><br><span class="line">       lastPos = high;</span><br><span class="line">       for(int i=low;i&lt;lastPos;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           if(a[i]&gt;a[i+1])</span><br><span class="line">           &#123;</span><br><span class="line">               int  temp = a[i];</span><br><span class="line">               a[i]= a[i+1];</span><br><span class="line">               a[i+1] = temp;</span><br><span class="line">               high = i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if(high==lastPos)  //没有交换位置</span><br><span class="line">       &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">       lastPos = low;</span><br><span class="line">       for(int i=high-1;i&gt;lastPos;i--)</span><br><span class="line">       &#123;</span><br><span class="line">           if(a[i]&gt;a[i+1])</span><br><span class="line">           &#123;</span><br><span class="line">               int  temp = a[i];</span><br><span class="line">               a[i]= a[i+1];</span><br><span class="line">               a[i+1] = temp;</span><br><span class="line">               low = i;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">        if(low==lastPos)  //没有交换位置</span><br><span class="line">       &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int a[11] = &#123;0,1,4,5,6,3,2,8,7,9,10&#125;;</span><br><span class="line">    BubbleSort(a,11);</span><br><span class="line">    cout&lt;&lt;&quot;冒泡排序: &quot;;</span><br><span class="line">    for(int i =0 ;i &lt; 11;i++)</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">     int b[11] = &#123;0,1,4,5,6,3,2,8,10,7,9&#125;;</span><br><span class="line">     DoubleBubbleSort(b,11);</span><br><span class="line">     cout&lt;&lt;&quot;双向冒泡排序：&quot;;</span><br><span class="line">      for(int i =0 ;i &lt; 11;i++)</span><br><span class="line">    cout&lt;&lt;b[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/11/5cff018c3521a47453.png" alt></p><h3 id="四、快速排序"><a href="#四、快速排序" class="headerlink" title="四、快速排序"></a>四、快速排序</h3><blockquote><p>快速排序（Quicksort）是对冒泡排序的一种改进。<br>快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><h4 id="1-时间性能：O-N-log2N"><a href="#1-时间性能：O-N-log2N" class="headerlink" title="1.时间性能：O(N*log2N)"></a>1.时间性能：O(N*log<sub>2</sub>N)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// Partition一次排序，每一次都找到一个轴值</span><br><span class="line">int Partition(int a[],int f,int e)</span><br><span class="line">&#123;</span><br><span class="line">    int i = f ,j=e;</span><br><span class="line">    while(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        while(i&lt;j&amp;&amp;a[i]&lt;=a[j])j--;</span><br><span class="line">        if(i&lt;j)&#123;</span><br><span class="line">            int temp = a[i];</span><br><span class="line">            a[i]=a[j];</span><br><span class="line">            a[j] =temp;</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         while(i&lt;j&amp;&amp;a[i]&lt;=a[j])i++;</span><br><span class="line">          if(i&lt;j)&#123;</span><br><span class="line">            int temp = a[i];</span><br><span class="line">            a[i]=a[j];</span><br><span class="line">            a[j] =temp;</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for(int i =0 ;i &lt; 11;i++)</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;轴值：&quot;&lt;&lt;i&lt;&lt;&quot;;  &quot;;</span><br><span class="line">      for(int i =0 ;i &lt; 11;i++)</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">        return i;</span><br><span class="line">&#125;</span><br><span class="line">//挨个找轴值，找到序列长度为1的轴值，排序就结束了</span><br><span class="line">void QuickSort(int a[],int f,int e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if(f&lt;e)</span><br><span class="line">    &#123;</span><br><span class="line">       int p = Partition(a,f,e);</span><br><span class="line">        QuickSort(a,f,p-1);</span><br><span class="line">    QuickSort(a,p+1,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">int a[11] = &#123;0,4,1,5,6,3,2,8,7,9,10&#125;;</span><br><span class="line">    QuickSort(a,0,11);</span><br><span class="line">    for(int i =0 ;i &lt; 11;i++)</span><br><span class="line">    cout&lt;&lt;a[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/11/5cff06c07b8ba43218.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、插入排序&quot;&gt;&lt;a href=&quot;#一、插入排序&quot; class=&quot;headerlink&quot; title=&quot;一、插入排序&quot;&gt;&lt;/a&gt;一、插入排序&lt;/h3&gt;&lt;h4 id=&quot;1-是一种简单直观且稳定的排序算法。&quot;&gt;&lt;a href=&quot;#1-是一种简单直观且稳定的排序算法。&quot;
      
    
    </summary>
    
      <category term="数据结构" scheme="www.yqxblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="www.yqxblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Unity-储存游戏数据的方式</title>
    <link href="www.yqxblog.top/unity/Unity-%E5%82%A8%E5%AD%98%E6%B8%B8%E6%88%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>www.yqxblog.top/unity/Unity-储存游戏数据的方式/</id>
    <published>2019-06-11T00:13:00.000Z</published>
    <updated>2019-09-23T15:39:54.404Z</updated>
    
    <content type="html"><![CDATA[ Unity 储存游戏数据的方式<a id="more"></a><h3 id="一、本地化txt文件"><a href="#一、本地化txt文件" class="headerlink" title="一、本地化txt文件"></a>一、本地化txt文件</h3><h4 id="在本地的Application-path路径中："><a href="#在本地的Application-path路径中：" class="headerlink" title="在本地的Application.path路径中："></a>在本地的Application.path路径中：</h4><p>1.Application.persistentDataPath 持久数据路径,APP更新时不会删除此数据<br>2.Application.dataPath 数据路径(Assets目录)  例：E:/Work/cosmosbox/cb-client/<br>3.AssetsApplication.streamingAssetsPath (Assets/StreamingAssets目录),AssetBundle一般存放在此目录下,可以通过www读取<br>4.Application.temporaryCachePath 操作系统的临时缓存目录 ，例： Z:/TEMP/Cosmosbox/ [我的电脑把缓存文件设置在Z盘]</p><h4 id="io流输入输出用C-的-TODO-补充C-io流"><a href="#io流输入输出用C-的-TODO-补充C-io流" class="headerlink" title="io流输入输出用C#的 //TODO 补充C#io流"></a>io流输入输出用C#的 //TODO 补充C#io流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String filename;</span><br><span class="line">String path;</span><br><span class="line">if (!File.Exists(path+filename))</span><br><span class="line">&#123;</span><br><span class="line">   Directory.CreateDirectory(path);    //创建一个文件夹</span><br><span class="line">   FIleStream fsl = new FileStream(path+filename, FileMode.Create, FileAccess.Write);  //创建一个可读写的文件</span><br><span class="line">&#125;</span><br><span class="line">//1.读操作</span><br><span class="line">StreamReader sw = new StreamReader(path+filename);</span><br><span class="line">String str = sw.ReadLine();</span><br><span class="line">sw.close();</span><br><span class="line">//2.写操作</span><br><span class="line">StreamWriter sw = new StreamWriter(path+filename);</span><br><span class="line">sw.WriteLine(str);</span><br><span class="line">sw.close();</span><br></pre></td></tr></table></figure><h3 id="二、放到-PlayerPrefs-中"><a href="#二、放到-PlayerPrefs-中" class="headerlink" title="二、放到 PlayerPrefs 中"></a>二、放到 PlayerPrefs 中</h3><p>1、Unity3D中的数据持久化是以键值的形式存储的，可以看作是一个字典。<br>2、Unity3D中值是通过键名来读取的，当值不存在时，返回默认值。<br>在Unity3D中只支持int、string、float三种数据类型的读取.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SetInt(key);SetFloat(key);SetString(key);</span><br><span class="line">GetInt(key);GetFloat(key);GetString(key);</span><br><span class="line">DelteAll();</span><br><span class="line">DeletKey(key);</span><br><span class="line">HasKey(key);</span><br></pre></td></tr></table></figure></p><p>持久化，一般是放不变的数据</p><h3 id="三、Json-数据加密"><a href="#三、Json-数据加密" class="headerlink" title="三、Json+数据加密"></a>三、Json+数据加密</h3><h4 id="1-Json"><a href="#1-Json" class="headerlink" title="1.Json"></a>1.Json</h4><h5 id="（1-Unity自带的Unity"><a href="#（1-Unity自带的Unity" class="headerlink" title="（1). Unity自带的Unity"></a>（1). Unity自带的Unity</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">calss Student&#123;&#125;</span><br><span class="line">Student m;</span><br><span class="line">JsonUtility.ToJson(m);</span><br><span class="line">String str;  //Json字符串</span><br><span class="line">(Student)JsonUtility.FromJson&lt;Student&gt;(str);</span><br></pre></td></tr></table></figure><h5 id="2-SimpleJson"><a href="#2-SimpleJson" class="headerlink" title="(2).SimpleJson"></a>(2).SimpleJson</h5><p><a href>点我</a></p>]]></content>
    
    <summary type="html">
    
      Unity 储存游戏数据的方式
    
    </summary>
    
      <category term="unity" scheme="www.yqxblog.top/categories/unity/"/>
    
    
      <category term="unity" scheme="www.yqxblog.top/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>unity canvas</title>
    <link href="www.yqxblog.top/unity/unity_canvas/"/>
    <id>www.yqxblog.top/unity/unity_canvas/</id>
    <published>2019-06-10T12:56:00.000Z</published>
    <updated>2019-09-23T15:40:15.989Z</updated>
    
    <content type="html"><![CDATA[ Canvas<a id="more"></a><h2 id="画布（Canvas）"><a href="#画布（Canvas）" class="headerlink" title="画布（Canvas）"></a>画布（Canvas）</h2><p>　Canvas画布是承载所有UI元素的区域。Canvas实际上是一个游戏对象上绑定了Canvas组件。所有的UI元素都必须是Canvas的自对象。如果场景中没有画布，那么我们创建任何一个UI元素，都会自动创建画布，并且将新元素置于其下。</p><h3 id="一、渲染模式"><a href="#一、渲染模式" class="headerlink" title="一、渲染模式"></a>一、渲染模式</h3><h4 id="1-Screen-Space-Overlay模式"><a href="#1-Screen-Space-Overlay模式" class="headerlink" title="1.Screen Space-Overlay模式"></a>1.Screen Space-Overlay模式</h4><p> Screen Space-Overlay（屏幕控件-覆盖模式）的画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层，或者说画布的画面永远“覆盖”其他普通的3D画面，如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕。<br>Screen Space-Overlay模式的画布有Pixel Perfect和Sort Layer两个参数：<br>　　（1）Pixel Perfect：只有RenderMode为Screen类型时才有的选项。使UI元素像素对应，效果就是边缘清晰不模糊。<br>　　（2）Sort Layer: Sort Layer是UGUI专用的设置，用来指示画布的深度。</p><h4 id="2-Screen-Space-Camera"><a href="#2-Screen-Space-Camera" class="headerlink" title="2.Screen Space-Camera"></a>2.Screen Space-Camera</h4><p> （屏幕空间-摄影机模式）和Screen Space-Overlay模式类似，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来 绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。在此模式下，UI元素是由perspective也就是视角设定的，视角广度由Filed of View设置。</p><p>　　这种模式可以用来实现在UI上显示3D模型的需求，比如很多MMO游戏中的查看人物装备的界面，可能屏幕的左侧有一个运动的3D人物，左侧是一些UI元素。通过设置Screen Space-Camera模式就可以实现上述的需求。<br>  　它比Screen Space-Overlay模式的画布多了下面几个参数：</p><p>　　（1）Render Camera:渲染摄像机</p><p>　　（2）Plane Distance:画布距离摄像机的距离</p><p>　　（3）Sorting Layer: Sorting Layer是UGUI专用的设置，用来指示画布的深度。可以通过点击该栏的选项，在下拉菜单中点击“Add Sorting Layer”按钮进入标签和层的设置界面，或者点击导航菜单-&gt;edit-&gt;Project Settings-&gt;Tags and Layers进入该页面。</p><p>　　　　可以点击“+”添加Layer，或者点击“-”删除Layer。画布所使用的Sorting Layer越排在下面，显示的优先级也就越高。</p><p>　　（4）Order in Layer:在相同的Sort Layer下的画布显示先后顺序。数字越高，显示的优先级也就越高。</p><h4 id="3-World-Space"><a href="#3-World-Space" class="headerlink" title="3.World Space"></a>3.World Space</h4><p> World Space即世界控件模式。在此模式下，画布被视为与场景中其他普通游戏对象性质相同的类似于一张面片（Plane）的游戏物体。画布的尺寸可以通过RectTransform设置，所有的UI元素可能位于普通3D物体的前面或者后面显示。当UI为场景的一部分时， 　　可以使用这个模式。</p><p>　　它有一个单独的参数Event Camera，用来指定接受事件的摄像机，可以通过画布上的GraphicRaycaster组件发射射线产生事件。</p><p>　　这种模式可以用来实现跟随人物移动的血条或者名称。<br>  我们通过下面的表格可以对比一下三种渲染模式的区别：<br><img src="https://i.loli.net/2019/06/11/5cfef0be64b0891326.png" alt></p><h3 id="TODO-Screen-Match-mode"><a href="#TODO-Screen-Match-mode" class="headerlink" title="//TODO Screen Match mode"></a>//TODO Screen Match mode</h3>]]></content>
    
    <summary type="html">
    
      Canvas
    
    </summary>
    
      <category term="unity" scheme="www.yqxblog.top/categories/unity/"/>
    
    
      <category term="unity" scheme="www.yqxblog.top/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>Oracle--上机实验2</title>
    <link href="www.yqxblog.top/Oracle/oracle%E5%AE%9E%E9%AA%8C2/"/>
    <id>www.yqxblog.top/Oracle/oracle实验2/</id>
    <published>2019-06-05T15:24:17.075Z</published>
    <updated>2019-06-05T15:26:48.699Z</updated>
    
    <content type="html"><![CDATA[程序块，程序包 <a id="more"></a> <escape>第一步：建表：<escape><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">drop table emp;</span><br><span class="line">drop table dept;</span><br><span class="line">create table dept(</span><br><span class="line">       deptno number(10) primary key,</span><br><span class="line">       dname varchar2(30),</span><br><span class="line">       loc varchar2(30)</span><br><span class="line">)</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">       empno number(10) primary key,</span><br><span class="line">       ename varchar2(30),</span><br><span class="line">       job varchar2(30),</span><br><span class="line">       mgr varchar2(30),</span><br><span class="line">       hiredate number(10),</span><br><span class="line">       sal number(10),</span><br><span class="line">       comm number(10),</span><br><span class="line">       deptno number(10),</span><br><span class="line">       foreign key(deptno) references dept(deptno)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第二步：向各表中插入数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">insert into dept values(1, &apos;技术部&apos; ,&apos;南泥湾&apos;);</span><br><span class="line">insert into dept values(2, &apos;SALES&apos; ,&apos;深圳市&apos;);</span><br><span class="line">insert into dept values(3, &apos;事业部&apos; ,&apos;北京市&apos;);</span><br><span class="line">insert into dept values(4, &apos;服务部&apos; ,&apos;延安&apos;);</span><br><span class="line">insert into dept values(5, &apos;生产部&apos; ,&apos;南京市&apos;);</span><br><span class="line">insert into dept values(6, &apos;宣传部&apos; ,&apos;上海市&apos;);</span><br><span class="line">insert into dept values(7, &apos;打杂部&apos; ,&apos;广州市&apos;);</span><br><span class="line">insert into dept values(8, &apos;司令部&apos; ,&apos;重庆市&apos;);</span><br><span class="line">insert into dept values(9, &apos;卫生部&apos; ,&apos;长沙市&apos;);</span><br><span class="line">insert into dept values(10, &apos;文化部&apos; ,&apos;武冈市&apos;);</span><br><span class="line">insert into dept values(11, &apos;娱乐部&apos; ,&apos;纽约&apos;);</span><br><span class="line">insert into dept values(12, &apos;管理部&apos; ,&apos;伦敦&apos;);</span><br><span class="line">insert into dept values(13, &apos;行政部&apos; ,&apos;天津市&apos;);</span><br><span class="line">select * from dept;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">insert into emp values(1, &apos;关羽羽&apos;, &apos;CLERK&apos; ,&apos;刘备备&apos;, 20011109, 2000, 1000, 3);</span><br><span class="line">insert into emp values(2, &apos;SMITH&apos;, &apos;CLERK&apos; ,&apos;刘备备&apos;, 20120101, 2000, 800, 6);</span><br><span class="line">insert into emp values(3, &apos;刘备备&apos;, &apos;MANAGER&apos; ,&apos;宋祖英&apos;, 20080808, 9000, 4000, 3);</span><br><span class="line">insert into emp values(4, &apos;TOM&apos;, &apos;ENGINEER&apos; ,&apos;Steve&apos;, 20050612, 3000, 1000, 1);</span><br><span class="line">insert into emp values(5, &apos;Steve&apos;, &apos;MANAGER&apos; ,&apos;宋祖英&apos;, 20110323, 80000, 9000, 1);</span><br><span class="line">insert into emp values(6, &apos;张飞飞&apos;, &apos;CLERK&apos; ,&apos;刘备备&apos;, 20101010, 2000, 1000, 3);</span><br><span class="line">insert into emp values(7, &apos;SCOTT&apos;, &apos;CLERK&apos; ,&apos;刘备备&apos;, 20071204, 2000, 1000, 3);</span><br><span class="line">insert into emp values(8, &apos;宋祖英&apos;, &apos;Boss&apos; ,&apos;无&apos;, 20060603, 2000, 1000, 8);</span><br><span class="line">insert into emp values(9, &apos;曹仁人&apos;, &apos;SALESMAN&apos; ,&apos;曹操操&apos;, 20120130, 2000, 1000, 2);</span><br><span class="line">insert into emp values(10, &apos;曹操操&apos;, &apos;MANAGER&apos; ,&apos;宋祖英&apos;,20090815, 2000, 1000, 2);</span><br><span class="line">insert into emp values(11, &apos;酱油哥&apos;, &apos;HAPI&apos; ,&apos;XXX&apos;,20090215, 3, 1, 2);</span><br></pre></td></tr></table></figure><p>游标更新操作 将所有工资位1000以下的变成1500 所有大于1000的乘以1.5 所有大于10000的变成10000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SET ServerOutput ON;</span><br><span class="line">Declare </span><br><span class="line">  cursor c_1 is </span><br><span class="line">         select empno,sal from emp</span><br><span class="line">         for update of sal nowait;</span><br><span class="line">  v_sal emp.sal%type;</span><br><span class="line">  </span><br><span class="line">Begin</span><br><span class="line">  for v_1 in c_1 </span><br><span class="line">    Loop</span><br><span class="line">      if(v_1.sal&lt;=1000) then v_sal:=1500;</span><br><span class="line">      else </span><br><span class="line">        v_sal :=v_1.sal*1.5;</span><br><span class="line">        if(v_sal&gt;10000)then v_sal := 10000;</span><br><span class="line">      end if;</span><br><span class="line">    end if;</span><br><span class="line">    update emp set sal=v_sal where current of c_1;</span><br><span class="line">    end loop;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></p><p>程序过程<br>：</p><p>1.简单的procedure<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> select empno,ename from emp;</span><br><span class="line"></span><br><span class="line">SET ServerOutput ON;</span><br><span class="line">create or replace procedure update_emp as</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">  update emp set ename=&apos;关羽&apos; where empno =1; </span><br><span class="line">end update_emp;</span><br><span class="line"></span><br><span class="line">Begin </span><br><span class="line">  update_emp();</span><br><span class="line">End;</span><br></pre></td></tr></table></figure></p><p>2.有程序包的procedure<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create or replace package test1 </span><br><span class="line">is</span><br><span class="line">  procedure t1;</span><br><span class="line">  procedure t2;</span><br><span class="line">  function t3 return number;</span><br><span class="line"></span><br><span class="line">end test1;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create or replace package body test1 </span><br><span class="line"></span><br><span class="line">as</span><br><span class="line">    procedure t1  as </span><br><span class="line">         begin    </span><br><span class="line">          </span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(sysdate);</span><br><span class="line">         end;</span><br><span class="line">    procedure t2 as</span><br><span class="line">      begin</span><br><span class="line">         update emp set ename=&apos;关羽&apos; where empno =1;</span><br><span class="line">         end;</span><br><span class="line">    function t3  return number is</span><br><span class="line">      begin</span><br><span class="line">         return 1;</span><br><span class="line">         end;</span><br><span class="line">         </span><br><span class="line">end test1;</span><br><span class="line">extc test1.t1;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SET ServerOutput ON;</span><br><span class="line">Begin </span><br><span class="line">  test1.t1();</span><br><span class="line">End;</span><br><span class="line">SET ServerOutput ON;</span><br><span class="line">Begin </span><br><span class="line">  test1.t2();</span><br><span class="line">End;</span><br><span class="line">SET ServerOutput ON;</span><br><span class="line">Begin </span><br><span class="line">  test1.t3();</span><br><span class="line">End;</span><br></pre></td></tr></table></figure><p>select avg(sal),count(*) from emp;</p><p>1.程序块 找出deptno=？ 的平均工资和人数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure return_deptinfo</span><br><span class="line">(</span><br><span class="line"> p_deptno in emp.deptno%type,</span><br><span class="line"> p_avgsal out emp.sal%type,</span><br><span class="line"> p_count out emp.sal%type</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">    select avg(sal),count(*)  into p_avgsal,p_count from emp</span><br><span class="line">    where</span><br><span class="line">    deptno = p_deptno ;</span><br><span class="line">end return_deptinfo;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SET ServerOutput ON;</span><br><span class="line">Declare </span><br><span class="line">   p_deptno  emp.deptno%type := 1;</span><br><span class="line">   p_avgsal  emp.sal%type;</span><br><span class="line">   p_count  emp.sal%type;</span><br><span class="line">Begin </span><br><span class="line">  return_deptinfo(p_deptno,p_avgsal,p_count);</span><br><span class="line">   DBMS_OUTPUT.PUT_LINE(p_avgsal||&apos;;&apos;||p_count);</span><br><span class="line">End;</span><br></pre></td></tr></table></figure><p>2.找到no中比平均工资高的员工并显示出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure show_emp</span><br><span class="line">(</span><br><span class="line"> p_deptno in emp.deptno%type</span><br><span class="line">)</span><br><span class="line">as</span><br><span class="line">v_sal emp.sal%type;</span><br><span class="line">Begin</span><br><span class="line">   select avg(sal) into v_sal from emp where deptno = p_deptno;</span><br><span class="line">   DBMS_OUTPUT.PUT_LINE(p_deptno||&apos;的平均工资：&apos;||v_sal);</span><br><span class="line">   </span><br><span class="line">     DBMS_OUTPUT.PUT_LINE(&apos;P_deptno为&apos;||p_deptno||&apos;中比平均工资高的&apos;);</span><br><span class="line">   for v_emp in(select * from emp where</span><br><span class="line">      deptno=p_deptno AND sal&gt;v_sal )</span><br><span class="line">      Loop</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&apos;empno：&apos;||v_emp.empno||&apos;name： &apos;||v_emp.ename);</span><br><span class="line">      end Loop;</span><br><span class="line">end show_emp;</span><br><span class="line">SET ServerOutput ON;</span><br><span class="line">Declare </span><br><span class="line">   p_deptno  emp.deptno%type := 1;</span><br><span class="line">  Begin  </span><br><span class="line">    show_emp(p_deptno);</span><br><span class="line">    End;</span><br></pre></td></tr></table></figure></p></escape></escape>]]></content>
    
    <summary type="html">
    
      程序块，程序包
    
    </summary>
    
      <category term="Oracle" scheme="www.yqxblog.top/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="www.yqxblog.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle--上机实验1</title>
    <link href="www.yqxblog.top/Oracle/oracle%E5%AE%9E%E9%AA%8C/"/>
    <id>www.yqxblog.top/Oracle/oracle实验/</id>
    <published>2019-06-05T15:23:50.736Z</published>
    <updated>2019-06-05T15:28:46.810Z</updated>
    
    <content type="html"><![CDATA[建表。。。。游标的使用 <a id="more"></a> <escape><escape><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select tablespace_name as 表空间名,SUM(bytes)</span><br><span class="line">from dba_data_files</span><br><span class="line">group by tablespace_name;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t_stu(  </span><br><span class="line">  stuid      number(10)   primary key not null,  </span><br><span class="line">  stuname    varchar2(20) not null,  </span><br><span class="line">  stusex     varchar2(2)  default &apos;男&apos; check(stusex in(&apos;男&apos;,&apos;女&apos;))</span><br><span class="line">)TABLESPACE T1;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table xs(  </span><br><span class="line">   xh      varchar2(26)   primary key not null ,</span><br><span class="line">   xs_name varchar2(20)   not null,</span><br><span class="line">   sex     varchar2(2)    default &apos;男&apos; check(sex in(&apos;男&apos;,&apos;女&apos;))</span><br><span class="line">)TABLESPACE T1;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert  into xs(xh,xs_name,sex) values(20171746,&apos;虞启贤&apos;,&apos;男&apos;);</span><br><span class="line">insert  into xs(xh,xs_name,sex) values(20171828,&apos;张雪微&apos;,&apos;女&apos;);</span><br><span class="line">insert  into xs(xh,xs_name,sex) values(20171755,&apos;花解语&apos;,&apos;女&apos;);</span><br><span class="line">insert  into xs(xh,xs_name,sex) values(20171745,&apos;叶伏天&apos;,&apos;男&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add constraint 约束名 约束内容。</span><br><span class="line">for example:</span><br><span class="line">alter table xs add constraint pk primaey key xh;</span><br><span class="line">alter table xs add constraint ck     check(sex==&apos;男&apos;or sex ==&apos;女&apos;);  //and or </span><br><span class="line">alter table xs add constraint un_xh unique(xh); //列值唯一</span><br><span class="line">-增加主键     </span><br><span class="line">alter table 表名 add constraint 主键名 primary key (字段名1);</span><br><span class="line">-增加外键:     </span><br><span class="line">alter table 表名 add constraint 外键名 foreign key (字段名1) references 关联表 (字段名2);</span><br><span class="line">alter table xs move tablespace T2;         //  将xs表从表空间t1转移到t2；</span><br><span class="line">alter table xs modify(sex default &apos;男&apos;) ;  // 修改sex列的默认值</span><br><span class="line">drop table t_stu;                        //删除表</span><br><span class="line"> </span><br><span class="line"> CREATE PUBLIC SYNONYM x FOR xs;  //增加同义词 </span><br><span class="line"> DROP SYNONYM s_dept;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 1.修改列的长度  </span><br><span class="line">      alter table dept modify loc varchar2(50);</span><br><span class="line">  </span><br><span class="line">2. 修改列的精度  </span><br><span class="line">      alter table employee_info modify empno number(2);</span><br><span class="line">  </span><br><span class="line">3. 修改列的数据类型  </span><br><span class="line">      alter table employee_info modify sex char(2); </span><br><span class="line"> </span><br><span class="line">4. 修改默认值  </span><br><span class="line">      alter table employee_info modify hiredate default sysdate+1; </span><br><span class="line"> </span><br><span class="line">5.禁用约束  </span><br><span class="line">  alter table employee_info disable constraint uq_emp_info;</span><br><span class="line">  </span><br><span class="line">6.启用约束  </span><br><span class="line">  alter table employee_info enable constraint uq_emp_info;  </span><br><span class="line">7.延迟约束  </span><br><span class="line">  alter table employee_info drop constraint fk_emp_info;  </span><br><span class="line">  alter table employee_info add constraint fk_emp_info foreign key(deptno)  </span><br><span class="line">        references dept(deptno)  </span><br><span class="line">  deferrable initially deferred;  </span><br><span class="line">8.向表中添加注释  </span><br><span class="line">  comment on table employee_info is &apos;information of employees&apos;;</span><br><span class="line">  </span><br><span class="line">9.向列添加注释  </span><br><span class="line">  comment on column employee_info.ename is &apos;the name of employees&apos;;  </span><br><span class="line">  comment on column dept.dname is &apos;the name of department&apos;;  </span><br><span class="line">10.清除表中所有数据  </span><br><span class="line">  truncate table employee_info; (DELETE FROM table_name或DELETE * FROM table_name)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare </span><br><span class="line"> var sex :=&apos;男&apos;;</span><br><span class="line"> v_sex xs%rowtype</span><br><span class="line">begin</span><br><span class="line"> select * into x_sex form xs so</span><br><span class="line"> where so.sex=sex;</span><br></pre></td></tr></table></figure><p>游标的使用：<br>游标的属性   返回值类型   意    义<br>%ROWCOUNT   整型  获得FETCH语句返回的数据行数<br>%FOUND  布尔型 最近的FETCH语句返回一行数据则为真，否则为假<br>%NOTFOUND   布尔型 与%FOUND属性返回值相反<br>%ISOPEN 布尔型 游标已经打开时值为真，否则为假<br>简单使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DECLARE </span><br><span class="line">  v_xh NUMBER;</span><br><span class="line">  v_name VARCHAR2(26);</span><br><span class="line">  Cursor Mycur IS</span><br><span class="line">  Select xh,xs_name from xs </span><br><span class="line">  where xh=20171746</span><br><span class="line">  ;</span><br><span class="line">Begin </span><br><span class="line">   </span><br><span class="line">   open Mycur ;</span><br><span class="line">   Fetch Mycur into v_xh,v_name ; </span><br><span class="line">   close Mycur;</span><br><span class="line">   </span><br><span class="line">   dbms_output.put_line(&apos;学生学号：&apos;||v_xh||&apos; 学生姓名:&apos;||v_name||&apos; 已执行的数据行数：&apos;);</span><br><span class="line">   </span><br><span class="line">End;</span><br></pre></td></tr></table></figure></p><p>1.隐式使用游标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Begin</span><br><span class="line">  Update xs set sex=&apos;女&apos; where sex = &apos;男&apos;;</span><br><span class="line">  IF SQL%FOUND THEN</span><br><span class="line">    DBMS_OUTPUT.put_line(&apos;成功将男性De改为女性&apos;);</span><br><span class="line">    COMMIT;</span><br><span class="line">    ELSE</span><br><span class="line">     DBMS_OUTPUT.put_line(&apos;UPDATE 失败&apos;); </span><br><span class="line">     END IF;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">Update xs set sex=&apos;男&apos; where xh=20171746;</span><br><span class="line">SET serveroutput on;</span><br></pre></td></tr></table></figure></p><p>2.用rowtype+游标 提取是男性的学生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Declare</span><br><span class="line">     Cursor v_cursor IS</span><br><span class="line">     select * from xs s where s.sex = &apos;男&apos;;</span><br><span class="line">     v_xs v_cursor%ROWTYPE;  </span><br><span class="line">Begin</span><br><span class="line">     IF v_cursor%ISOPEN=false Then</span><br><span class="line">       open v_cursor;</span><br><span class="line">      END IF;</span><br><span class="line">      </span><br><span class="line">      Fetch  v_cursor into v_xs ;</span><br><span class="line">      </span><br><span class="line">      While v_cursor%Found</span><br><span class="line">        LOOP</span><br><span class="line">           DBMS_OUTPUT.PUT_LINE(&apos;学号：&apos;||v_xs.xh||&apos; 姓名：&apos;||v_xs.xs_name||&apos; 性别：&apos;||v_xs.sex); </span><br><span class="line">           DBMS_OUTPUT.PUT_LINE(&apos;已执行行数:&apos;||v_cursor%rowcount);</span><br><span class="line">            Fetch  v_cursor into v_xs ;</span><br><span class="line">        End LOOP;</span><br><span class="line">        </span><br><span class="line">        CLOSE v_cursor;  </span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p><p>3.显示学号大小前三的学生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Declare </span><br><span class="line">    Cursor v_c IS</span><br><span class="line">     select * from xs order BY xh DESC;</span><br><span class="line">    v_xs v_c%rowtype;</span><br><span class="line">   </span><br><span class="line">BEGIN</span><br><span class="line">  open v_c;</span><br><span class="line">  </span><br><span class="line">    FOR I in 1..3 LOOP</span><br><span class="line">      Fetch v_c into v_xs;</span><br><span class="line">      dbms_output.put_line(&apos;学号：&apos;||v_xs.xh||&apos; 姓名：&apos;||v_xs.xs_name||&apos; 性别：&apos;||v_xs.sex);</span><br><span class="line">         END LOOP;</span><br><span class="line">         </span><br><span class="line">  close v_c;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure></p><p>4.特殊的FOR循环形式<br>(1).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Declare </span><br><span class="line">    Cursor v_c IS</span><br><span class="line">     select * from xs order BY xh DESC;</span><br><span class="line">BEGIN</span><br><span class="line">  FOR v_xs in v_c LOOP</span><br><span class="line">    dbms_output.put_line(&apos;学号：&apos;||v_xs.xh||&apos; 姓名：&apos;||v_xs.xs_name||&apos; 性别：&apos;||v_xs.sex);</span><br><span class="line">   END LOOP;</span><br><span class="line">  ENd;</span><br></pre></td></tr></table></figure></p><p>(2).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">  FOR v_xs in (select * from xs order BY xh DESC) LOOP</span><br><span class="line">    dbms_output.put_line(&apos;学号：&apos;||v_xs.xh||&apos; 姓名：&apos;||v_xs.xs_name||&apos; 性别：&apos;||v_xs.sex);</span><br><span class="line">   END LOOP;</span><br><span class="line">  ENd;</span><br></pre></td></tr></table></figure></p><p>5.带参数的游标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Declare</span><br><span class="line">     Cursor v_c(x_xh Number) IS</span><br><span class="line">     select * from xs where xh=x_xh ;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     v_xs v_c%rowtype;</span><br><span class="line">     </span><br><span class="line">BEgin</span><br><span class="line">     open v_c(20171755);</span><br><span class="line">     Fetch v_c into v_xs;</span><br><span class="line">     dbms_output.put_line(&apos;学号：&apos;||v_xs.xh||&apos; 姓名：&apos;||v_xs.xs_name||&apos; 性别：&apos;||v_xs.sex);</span><br><span class="line">     close v_c;</span><br><span class="line">End;</span><br></pre></td></tr></table></figure></p><p>6.游标变量的使用<br>(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SET ServerOutput ON;</span><br><span class="line">Declare</span><br><span class="line">Type cursor_type is ref cursor;</span><br><span class="line">c_1 cursor_type;</span><br><span class="line">r_1 xs%rowtype;</span><br><span class="line"></span><br><span class="line">Begin</span><br><span class="line">  open c_1 For select * from xs where xs.xh=&apos;20171746&apos;;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;已执行行数:&apos;||c_1%rowcount);</span><br><span class="line">  while c_1%found Loop</span><br><span class="line">    fetch c_1 into r_1;</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(&apos;已执行行数:&apos;||c_1%rowcount);</span><br><span class="line">       dbms_output.put_line(&apos;学号：&apos;||r_1.xh||&apos; 姓名：&apos;||r_1.xs_name||&apos; 性别：&apos;||r_1.sex);</span><br><span class="line">end loop;</span><br><span class="line">close c_1;</span><br><span class="line">End;</span><br></pre></td></tr></table></figure></p><p>(2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SET ServerOutput ON;</span><br><span class="line">Declare</span><br><span class="line">Type cursor_type is ref cursor return xs%rowtype;</span><br><span class="line">c_1 cursor_type;</span><br><span class="line">r_1 xs%rowtype;</span><br><span class="line"></span><br><span class="line">Begin</span><br><span class="line">  open c_1 For select * from xs;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;已执行行数:&apos;||c_1%rowcount);</span><br><span class="line">For i in c_1 Loop</span><br><span class="line">   dbms_output.put_line(&apos;学号：&apos;||i.xh||&apos; 姓名：&apos;||i.xs_name||&apos; 性别：&apos;||i.sex);</span><br><span class="line">End Loop;</span><br><span class="line"></span><br><span class="line">close c_1;</span><br><span class="line">End;</span><br></pre></td></tr></table></figure></p><p>(3)</p></escape></escape>]]></content>
    
    <summary type="html">
    
      建表。。。。游标的使用
    
    </summary>
    
      <category term="Oracle" scheme="www.yqxblog.top/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="www.yqxblog.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle--4</title>
    <link href="www.yqxblog.top/Oracle/Oracle---4/"/>
    <id>www.yqxblog.top/Oracle/Oracle---4/</id>
    <published>2019-05-30T09:57:15.165Z</published>
    <updated>2019-06-05T15:22:32.369Z</updated>
    
    <content type="html"><![CDATA[ <a id="more"></a> <escape># 一、数据库安全管理### 1、Oracle认证方法 操作系统认证：在cmd下sqlplus / ，则不要要用户名和密码了。 还有网络认证和数据库认证 数据库管理员认证 connect as /sysdba   忘记DBA口令是简单修改口令的方法 <escape><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlplus as/sysdba</span><br><span class="line">alter user sus identified by NEWPWD;</span><br><span class="line">commit;</span><br><span class="line">conn sys /as sysdba</span><br></pre></td></tr></table></figure><h3 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2.用户管理"></a>2.用户管理</h3><h4 id="（1）-创建用户"><a href="#（1）-创建用户" class="headerlink" title="（1）.创建用户"></a>（1）.创建用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create user 用户名</span><br><span class="line">identified by 口令</span><br><span class="line">default tablespace 默认表空间</span><br><span class="line">temporary tablespace 临时表空间</span><br></pre></td></tr></table></figure><h4 id="（2）-修改用户"><a href="#（2）-修改用户" class="headerlink" title="（2）.修改用户"></a>（2）.修改用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user 用户名 identified by NEWPWD  //修改密码</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user 用户名 password expire/lock/unlock //设置用户密码过期/锁定/解锁</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user 用户名 quata 表空间配额大小 on 表空间//位用户分配表空间配额</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user 用户名  //删除用户</span><br></pre></td></tr></table></figure><h3 id="3-角色管理"><a href="#3-角色管理" class="headerlink" title="3.角色管理"></a>3.角色管理</h3><blockquote><p>查看角色 select * from dba_roles;</p></blockquote><h4 id="1-创建角色"><a href="#1-创建角色" class="headerlink" title="(1).创建角色"></a>(1).创建角色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create role rolename identified by newwpd;</span><br></pre></td></tr></table></figure><h4 id="（2）-指定用户角色"><a href="#（2）-指定用户角色" class="headerlink" title="（2）.指定用户角色"></a>（2）.指定用户角色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant role to user;   //指定角色</span><br><span class="line">example:  grant connect to userman;</span><br><span class="line">revoke role from user //回收角色</span><br></pre></td></tr></table></figure><h4 id="（3）-修改角色"><a href="#（3）-修改角色" class="headerlink" title="（3）.修改角色"></a>（3）.修改角色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter role rolename not identified //取消rolename角色的密码验证</span><br><span class="line">drop role rolename //删除rolename角色</span><br></pre></td></tr></table></figure><h3 id="4-权限管理"><a href="#4-权限管理" class="headerlink" title="4.权限管理"></a>4.权限管理</h3></escape></escape>]]></content>
    
    <summary type="html">
    
      
      
         &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; &lt;escape&gt;
# 一、数据库安全管理

### 1、Oracle认证方法
 操作系统认证：在cmd下sqlplus / ，则不要要用户名和密码了。
 还有网络认证和数据库认证
 数据库管理员认证
 connect as /sysdba
 
      
    
    </summary>
    
      <category term="Oracle" scheme="www.yqxblog.top/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="www.yqxblog.top/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 语法的几个简单使用</title>
    <link href="www.yqxblog.top/normal/Markdown%E8%AF%AD%E6%B3%95%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>www.yqxblog.top/normal/Markdown语法的几个简单使用/</id>
    <published>2019-05-30T07:44:00.000Z</published>
    <updated>2019-06-11T01:03:52.741Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题-几个-号就是几个标题"><a href="#六级标题-几个-号就是几个标题" class="headerlink" title="六级标题 (几个#号就是几个标题)"></a>六级标题 (几个#号就是几个标题)</h6><hr><ul><li>sdsd</li><li>sdsd</li><li>sdsd  (-)</li></ul><p>1.ss<br>2.22<br>3.33</p><p><a href="www.baidu.com">baidu</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([]())</span><br></pre></td></tr></table></figure></p><blockquote><p>sdsdsdsda<br>sdsadsadasd  (&gt;)</p></blockquote><p><em>sddsd</em></p><p><strong>sdsdsd</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><table><thead><tr><th>dog</th><th>bird</th><th>cat</th></tr></thead><tbody><tr><td>foo</td><td>foo</td><td>foo</td></tr><tr><td>bar</td><td>bar</td><td>bar</td></tr><tr><td>baz</td><td>baz</td><td>baz</td></tr></tbody></table><p>![][1]<br>[1]: <a href="http://latex.codecogs.com/gif.latex?\prod%20\(n_{i}\)+1" target="_blank" rel="noopener">http://latex.codecogs.com/gif.latex?\prod%20\(n_{i}\)+1</a></p><h3 id="在MarkDown中打出上标、下标、及一些特殊符号"><a href="#在MarkDown中打出上标、下标、及一些特殊符号" class="headerlink" title="在MarkDown中打出上标、下标、及一些特殊符号"></a>在MarkDown中打出上标、下标、及一些特殊符号</h3><p><a href="https://www.jianshu.com/p/80ac23666a98" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Oracle---3</title>
    <link href="www.yqxblog.top/Oracle/Oracle---3/"/>
    <id>www.yqxblog.top/Oracle/Oracle---3/</id>
    <published>2019-05-25T12:40:00.000Z</published>
    <updated>2019-05-30T09:56:43.712Z</updated>
    
    <content type="html"><![CDATA[回滚段的管理、数据库文件管理（控制文件，重做日志文件，归档文件） <a id="more"></a><h2 id="一、回滚段的管理"><a href="#一、回滚段的管理" class="headerlink" title="一、回滚段的管理"></a>一、回滚段的管理</h2><p>1.查看回滚段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COL 回滚段名 FOR A20</span><br><span class="line">SELECT</span><br><span class="line">SEGMENT_NAME 回滚段名 , TABLESPACE_NAME 所在表空间，BYTES 大小</span><br><span class="line">FROM DBA_SEGMENTS WHERE SEGMENT_TYPE=&apos;ROLLBACK&apos;;</span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2019/05/25/5ce8ed98a941589164.png" alt></p><p>还可以使用视图 V$ROLLNAME 和视图 V$ROLLSTAT<br><img src="https://i.loli.net/2019/05/25/5ce8ee84c4d0230376.png" alt><br><img src="https://i.loli.net/2019/05/25/5ce8ee8600acd59452.png" alt></p><p>2.查看和设置回滚段的管理模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PARAMETER UNDO_MANAGEMENT</span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2019/05/25/5ce8efc2af30021304.png" alt><br><figure class="highlight plain"><figcaption><span>将回滚段管理模式设置为手动管理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter system set UNDO_MANAGEMENT = MANUAL</span><br><span class="line">SCOPE = SPFILE;</span><br></pre></td></tr></table></figure></p><p>3.创建回滚段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE [PUBLIC] ROLLBACK SEGMENT 回滚段名称</span><br><span class="line"> TABLESPACE T1</span><br><span class="line"> STORAGE 存储选项：&#123;</span><br><span class="line"> inital 5M</span><br><span class="line"> next 2M</span><br><span class="line"> maxextents unlimited</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>4.修改回滚段的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.设置状态</span><br><span class="line">alter rollback segment 回滚段名称 online</span><br><span class="line">2.手动收缩回滚段</span><br><span class="line">3.alter rollback segment 回滚段名称 shrink to 回滚段的初始大小</span><br></pre></td></tr></table></figure><br>5.删除回滚段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter rollback segment 回滚段名称 offline //先脱机</span><br><span class="line">drop rollback segment 回滚段名称</span><br></pre></td></tr></table></figure></p><hr><h2 id="二、数据库文件管理"><a href="#二、数据库文件管理" class="headerlink" title="二、数据库文件管理"></a>二、数据库文件管理</h2><p>1.SCN(System Change Number）<br>(1).控制文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from v$controlfile;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/05/30/5cefa06f1538063291.png" alt><br><img src="https://i.loli.net/2019/05/30/5cefa0d36563426778.png" alt><br><a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-CONTROLFILE.html#GUID-9B389F28-C4D0-405D-BFE6-48237E8BD791" target="_blank" rel="noopener">CREATE CONTROLFILE官方文档</a></p><p>(2).重做日志文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">col MEMBER  for A40</span><br><span class="line">select GROUP# ,MEMBER  from v$logfile(v$log);</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/05/30/5cefa3ac9b54b80023.png" alt></p><p>(3).归档日志管理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,log_mode from v$database;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.loli.net/2019/05/30/5cefa6d6ce67c56736.png" alt></p>]]></content>
    
    <summary type="html">
    
      回滚段的管理、数据库文件管理（控制文件，重做日志文件，归档文件）
    
    </summary>
    
      <category term="Oracle" scheme="www.yqxblog.top/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="www.yqxblog.top/tags/Oracle/"/>
    
  </entry>
  
</feed>
