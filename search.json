[{"title":"unity_Magical voxel创建结构体","url":"/unity/unity_Magical voxel创建结构体/","content":" \n- 主要目的，让magical voxel导出的vox 可以一个个像素块的方式推积\n\n\n## 具体过程\n\n### 1.将vox利用voxelImporter导入之后勾选上转换为structs\n### 2.再场景中创建空物体，加载这个物体，为其加上CreateCubes代码\n```\n   //* 将structs遍历上色 structs里面已经有了 每个块的位置，颜色。\n   每一个像素方块上色要先创建Cube，再确定其位置，父亲。\n   最后为其打上材质,renderer,rigbody\n   *//\n public class CreateCubes : MonoBehaviour\n    {\n        public VoxelStructure voxelStructure;\n\n        private Material[] materials;\n\n        public void Awake()\n        {\n            if (voxelStructure == null) return;\n\n            materials = new Material[voxelStructure.palettes.Length];\n            for (int i = 0; i < voxelStructure.palettes.Length; i++)\n            {\n                materials[i] = new Material(Shader.Find(\"Standard\"));\n                materials[i].name = string.Format(\"Palette {0}\", i);\n                materials[i].color = voxelStructure.palettes[i];\n            }\n\n            for (int i = 0; i < voxelStructure.voxels.Length; i++)\n            {\n                var go = GameObject.CreatePrimitive(PrimitiveType.Cube);\n                go.name = string.Format(\"{0} : ({1}, {2}, {3})\", i, voxelStructure.voxels[i].x, voxelStructure.voxels[i].y, voxelStructure.voxels[i].z);\n                go.transform.localPosition = voxelStructure.voxels[i].position;\n                go.transform.SetParent(transform);\n                {\n                    var renderer = go.GetComponent<Renderer>();\n                    renderer.sharedMaterial = materials[voxelStructure.voxels[i].palette];\n                }\n                {\n                    var rigidbody = go.AddComponent<Rigidbody>();\n                    rigidbody.isKinematic = true;\n                    rigidbody.Sleep();\n                }\n            }\n\n            enabled = false;\n        }\n    }\n   \n```\n\n### 3.触发改变结构体中的一个分离。\n\n```\npublic class TouchRigidbodyExplosion : MonoBehaviour\n\t{\n        public float radius = 10f;\n        public float power = 500f;\n\n        void Update()\n        {\n            bool explosion = false;\n            Vector3 position = Vector3.zero;\n            if (Input.GetMouseButtonDown(0))\n            {\n                explosion = true;\n                position = Input.mousePosition;\n            }\n            if (Input.touchCount > 0)\n            {\n                explosion = true;\n                position = Input.GetTouch(0).position;\n            }\n            if (explosion)\n            {\n                Ray ray = Camera.main.ScreenPointToRay(position);\n                RaycastHit hit;\n                if (Physics.Raycast(ray, out hit, 1000))\n                {\n                    var colliders = Physics.OverlapSphere(hit.point, radius);\n                    for (int i = 0; i < colliders.Length; i++)\n                    {\n                        var rigidbody = colliders[i].GetComponent<Rigidbody>();\n                        if (rigidbody == null) continue;\n\n                        rigidbody.isKinematic = false;\n\n                        rigidbody.AddExplosionForce(power, hit.point, radius);\n                    }\n                }\n            }\n        }\n\t}\n```","tags":["unity"],"categories":["unity"]},{"title":"unityShader——01","url":"/unity/unity_Shader01/","content":"\n# Shader 概述\n## 一、Shader--着色器 运行在图形处理单元，可以让开发人员直接操作图形硬件渲染\n### 1.Shader能开发出很好的效果，UV动画，水，雾等一些特效。\n### 2.过程 渲染流水线，模型投影，定点着色\n### 3.分类为\n  #### 顶点Shader 干预模型形态的shader\n  #### 像素Shader 干预像素着色的shader\n### 4.模型顶点运算的时候，可以加入顶点shader来干预顶点的位置；顶点着色的时候，加入像素shader来干预像素的上色；\n\n\n # GPU编程语言\n ## 1. Direct3D和opengl\n ### 2.分为三种\n#### (1). HLSL语言 -只能在Direct3D中使用\n#### (2).Cg语言 -与C相似，都支持\n#### (3).GLSL语言 - 只支持opengl\n### 3. unity使用ShaderLab来进行着色器的编写，对于不同的平台进行编译 重点支持cg语言\n \n \n # Shader Lab语法基础\n ## 1.定义一个Shader\n ```\n Shader \"name\"{ //name shader名字\n  // 定义的一些属性，定义在这里的会在属性查看器里面显示\n  [propeties]\n  //子着色器列表，一个Shader必须至少有一个子着色器；\n  SUbshaders:{....}\n  //如果子着色器显卡不支持，就会降级，即Fallback操作；\n  [Fallback]\n  }\n ```\n ## 2.Properties 定义\n ### (1). name{\"displayname\",type}=值\n- name：属性的名字，Unity中用下划线开始_Name;\n- displayname是指在属性检查器的名字；\n- type：这个属性的**类型**\n- 值:默认值\n \n ### (2).类型\n - FLoat,Int,Color(num,num,num,num)(0~1)Vector(4维向量),Range(start,end)\n - 2D:2D纹理属性\n - Rect：矩形纹理属性\n - Cube：立方体纹理属性\n - 3D：3D纹理属性\n\n ### (3). name{\"displayname\",2D}= \"name\"{options} Options纹理属性选项\n \n- TexGen：纹理生成模式，纹理自动生成纹理坐标的模式，顶点shader将会忽略这个选项；\n- ObjectLinear，EyeLinear，SphereMap，CubeReflect，CubeNormal\n- LightmapMod：光照贴图模式如果设置这个选项纹理会被渲染器的光线贴图所影响。\n\n``` 定义例子\n_Range{\"range value\",Range(0,1)}= 0.3; //定义了一个范围\n_Color(\"color\",Color)=(1,1,1,1) //定义了一歌颜色\n_MainText (\"Albedo\",Cube)=\"skybox\"{TexGen CubeReflect}  //定义一个立方贴图纹理属性；\n```\n\n\n\n## 3.SubShader \n### (1). SubShader{[Tags],[CommonState],Pass{}}\n子着色器由 标签，通用状态，通道了表组成，它定义了一个渲染通道列表，并可选为所有通道初始化许愿哦的通用状态；\n### （2). 通道类型：RegularPass，UsePass，GrabPass\n-一个子着色器有多个通道可以用一个通用状态\n\n ```\n SubShader{\n Tags{\"Queue\",\"Transparent\"}\n Pass{\n      Lightinig Off  //关闭光照\n      ...\n }\n }\n ```\n![](https://i.loli.net/2019/08/30/rhLtA76mZ8COes2.png)\n![](https://i.loli.net/2019/08/30/9TW3QnkxdpGAMmY.png)\n![](https://i.loli.net/2019/08/30/W2kCML97hlgZUEG.png)\n![](https://i.loli.net/2019/08/30/9amSXITAizlRVEK.png)\n ![](https://i.loli.net/2019/08/30/3oLnT4RMGNrE5pB.png)\n ![](https://i.loli.net/2019/08/30/DSzXnLqlruORK35.png)","tags":["unity"],"categories":["unity"]},{"title":"unity摄像机的移动","url":"/unity/unity摄像机移动/","content":"# 一、 普通的旋转\n 根据水平和垂直量进行旋转\n ### 第一种是比较简单的版本，\n 得到鼠标现在的位置与之前的位置作比较然后旋转\n```   \n        newMousePosition = Input.mousePosition;\n          hor = (newMousePosition.x - oldMousePosition.x) * sHor;\n          vert = (newMousePosition.y - oldMousePosition.y) * sVert;\n          print(\"hor:\"+hor);\n          print(\"vert:\"+ vert);\n          //hor = Mathf.Clamp(hor, MinHor, MaxHor);\n         // vert = Mathf.Clamp(vert, MinVert, MaxVert);\n\n          if (newMousePosition != oldMousePosition)\n          {\n              transform.Rotate(Vector3.up, hor);  // 水平方向旋转\n              transform.Rotate(Vector3.right, -1 * vert); //垂直方向旋转\n              transform.eulerAngles = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, 0);\n          }\n          oldMousePosition = Input.mousePosition;\n```\n\n### 第二种是略显复杂的版本\n- 水平旋转：\n- 垂直旋转：\n- 水平和垂直旋转：\n```\n  public enum RotationAxes\n        {\n               MouseXAndY = 0,\n               MouseX=1,\n            MouseY=2\n\n        };\n\n        public float sensitivityHor = 4.5f;\n        public float sensitivityVert = 4.5f;\n\n        public RotationAxes rotation = RotationAxes.MouseXAndY;\n\n        public  float MinVert = -45.0f;\n        public float MaxVert = 45.0f;\n        public float MinHorVert = -56f;\n        public float MaxHorVert = 55f;\n\n        public GameObject player;\n        private float _RotationX = 0.0f;\n\n    private Vector3 Dis;\n        private void Awake()\n        {\n             //init 初始时读取数据\n        }\n        // Use this for initialization\n        void Start () {\n        Dis = player.transform.position - this.transform.position;\n        }\n\n        // Update is called once per frame\n        void Update () {\n\n            if (rotation == RotationAxes.MouseX)\n            {\n                this.transform.Rotate(0, Input.GetAxis(\"Mouse X\") * sensitivityHor, 0);\n            }\n            else \n                if(rotation == RotationAxes.MouseY)\n            {\n                _RotationX -= Input.GetAxis(\"Mouse Y\") * sensitivityVert;\n                _RotationX = Mathf.Clamp(_RotationX, MinVert, MaxVert);\n                float RotationY = this.transform.localEulerAngles.y;\n\n                this.transform.localEulerAngles = new Vector3(_RotationX, RotationY, 0);\n\n            }\n        else if (rotation == RotationAxes.MouseXAndY)\n        {\n                _RotationX -= Input.GetAxis(\"Mouse Y\") * sensitivityVert;\n                _RotationX = Mathf.Clamp(_RotationX, MinVert, MaxVert);\n                float RotationY = this.transform.localEulerAngles.y + Input.GetAxis(\"Mouse X\") * sensitivityHor;\n                 RotationY = CheckAngle(RotationY);\n               \n                print(RotationY);\n                RotationY = Mathf.Clamp(RotationY, MinHorVert, MaxHorVert);\n                 HeadRotate(_RotationX,RotationY);\n\n                this.transform.localEulerAngles = new Vector3(_RotationX, RotationY, 0);\n\n           \n            }\n        MoveWithPlayer();\n\n    }\n\n      public void MoveWithPlayer()\n    {\n        this.transform.position = player.transform.position - Dis;\n    }\n        public void HeadRotate(float hor,float vert)\n        {\n        // 角色头部旋转\n        player.GetComponent<PlayerMove>().HeadeRotate(hor,vert);\n           \n         }\n         public float CheckAngle(float value)  // 将大于180度角进行以负数形式输出\n    {\n        float angle = value - 180;\n\n        if (angle > 0)\n        {\n            return angle - 180;\n        }\n\n        if (value == 0)\n        {\n            return 0;\n        }\n\n        return angle + 180;\n    }\n    \n\n```\n\n","tags":["unity"],"categories":["unity"]},{"url":"/normal/unity_03/","content":"```\npublic class groy : MonoBehaviour {\t\n\tvoid Awake()\n        {\n                //设置屏幕正方向在Home键右边\n                Screen.orientation = ScreenOrientation.LandscapeRight;\n        }\n \n        void Start () \n        {\n                //设置屏幕自动旋转， 并置支持的方向\n                Screen.orientation = ScreenOrientation.AutoRotation;\n                Screen.autorotateToLandscapeLeft = true;\n                Screen.autorotateToLandscapeRight = true;\n                Screen.autorotateToPortrait = false;\n                Screen.autorotateToPortraitUpsideDown = false;\n        }\n}\n\n\n```"},{"title":"设计模式之行为型","url":"/设计模式/设计模式之行为型/","content":"\n\n## 何谓行为型模式\n **行为型模式为设计模式的一种类型，用来识别对象之间的常用交流模式并加以实现。如此，可在进行这些交流活动时增强弹性。**\n - 观察者模式\n - 模板方法模式\n - 命令方法模式\n - 状态模式\n - 职责链模式\n - 解释器模式\n - 中介者模式\n - 访问者模式\n - 策略模式\n - 备忘录模式\n - 迭代器模式\n - ","tags":["设计模式"],"categories":["设计模式"]},{"title":"设计模式之结构型","url":"/设计模式/设计模式之结构型/","content":"\n## 何谓结构型设计模式\n**借由一以贯之的方式来了解元件间的关系，以简化设计。**\n#### 举例：\n\n - 适配器模式：将一个物体的界面‘转接’成当事人预期的样子\n - 桥接模式：将一个抽象与实现解耦，以便两者可以独立的变化。组合模式：树状结构的物件，每个物件有相同的界面\n - 装饰模式：对一个执行的类别，若使用继承方式加上新功能可能会新类别的数量呈指数型地增加，可使用此模式来解决。、\n - 组合模式：树状结构的物件，每个物件有相同的界面\n - 外观模式：对于已有的界面建立一个简化的界面以简化使用共通任务。\n - 享元模式：通过共享以便有效的支持大量小颗粒对象。\n - 代理模式：为其他对象提供一个代理以控制对这个对象的访问。\n \n >在我看来，结构型模式就是在不增加类的高内聚低耦合的情况利用继承，聚合，包含，将一个类的功能延伸或减少某个类的复杂性，\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"设计模式之创建型","url":"/设计模式/设计模式之创建型/","content":"\n## 何谓创建型模式?\n**创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。创建型模式通过以某种方式控制对象的创建来解决问题。**\n##### 1.创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。\n##### 2.创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。\n### 一、单例模式\n**目的：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n**举例：**\n　　在OS中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。\n ![](https://i.loli.net/2019/06/12/5d00ef8b776e039846.png)\n ```\npackage 单例模式;\n\npublic class Singleton {\n\tprivate static Singleton instance;\n\tSingleton() {\n\t\t\n\t}\n\tpublic Singleton GetInstance()\n\t{\n\t\tif(instance == null)\n\t\t{\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t\n}\npackage 单例模式;\n\npublic class Client {\n  public static void main(String[] args)\n  {\n\t  Singleton singleton = new Singleton();\n\t  Singleton s1 = singleton.GetInstance();\n\t  Singleton s2 = singleton.GetInstance();\n\t  Singleton s3 = new Singleton();\n\t  if(s1==s2)System.out.println(\"s1==s2\");\n\t  if(s1==s3)System.out.println(\"s1==s3\");\n  }\n}\n\n\nResult: s1==s2\n ```\n### 二、工厂方法模式\n**原理:**定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\n```\n#include <string>\n#include <iostream>\nusing namespace std;\n\n//实例基类，相当于Product(为了方便，没用抽象)\nclass LeiFeng\n{\npublic:\n    virtual void Sweep()\n    {\n        cout<<\"雷锋扫地\"<<endl;\n    }\n};\n\n//学雷锋的大学生，相当于ConcreteProduct（具体产品1）\nclass Student: public LeiFeng\n{\npublic:\n    virtual void Sweep()\n    {\n        cout<<\"大学生扫地\"<<endl;\n    }\n};\n\n//学雷锋的志愿者，相当于ConcreteProduct（具体产品2）\nclass Volenter: public LeiFeng\n{\npublic :\n    virtual void Sweep()\n    {\n        cout<<\"志愿者\"<<endl;\n    }\n};\n\n-----------------------------\n//工场基类Creator\nclass LeiFengFactory\n{\npublic:\n    virtual LeiFeng* CreateLeiFeng() //返回值体现依赖关系\n    {\n        return new LeiFeng();\n    }\n};\n\n//工场具体类1（创建大学生产品的具体工厂）\nclass StudentFactory : public LeiFengFactory\n{\npublic :\n    virtual LeiFeng* CreateLeiFeng() //返回值体现依赖关系\n    {\n        return new Student();\n    }\n};\n\n//工场具体类2（创建志愿者产品的具体工厂）\nclass VolenterFactory : public LeiFengFactory\n{\npublic:\n    virtual LeiFeng* CreateLeiFeng()\n    {\n        return new Volenter(); //返回值体现依赖关系\n    }\n};\n\n-----------------------------\n//客户端\nint main()\n{\n    LeiFengFactory *sf=new StudentFactory(); //由客户端选创建什么产品\n    LeiFeng *s=sf->CreateLeiFeng();\n    s->Sweep();\n    delete s;\n    delete sf;\n    return 0;\n}\n```\n### 三、抽象工厂模式\n**功能：**提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类。\n**优缺点：**遵循高内聚低耦合的设计目的，但无法避免开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦，或反之）\n**模式应用：**\n　在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。\n\n![](https://i.loli.net/2019/06/12/5d00f0bdba47d87017.png)\n```\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//用户抽象接口(抽象产品A)\nclass IUser\n{\npublic :\n    virtual void GetUser()=0;\n    virtual void InsertUser()=0;\n};\n\n//部门抽象接口(抽象产品B)\nclass IDepartment\n{\npublic:\n    virtual void GetDepartment()=0;\n    virtual void InsertDepartment()=0;\n};\n\n//ACCESS用户（抽象产品A的产品1）\nclass CAccessUser : public IUser\n{\npublic:\n    virtual void GetUser()\n    {\n        cout<<\"Access GetUser\"<<endl;\n    }\n    virtual void InsertUser()\n    {\n        cout<<\"Access InsertUser\"<<endl;\n    }\n};\n\n//ACCESS部门（抽象产品B的产品1）\nclass CAccessDepartment : public IDepartment\n{\npublic:\n    virtual void GetDepartment()\n    {\n        cout<<\"Access GetDepartment\"<<endl;\n    }\n    virtual void InsertDepartment()\n    {\n        cout<<\"Access InsertDepartment\"<<endl;\n    }\n};\n\n//SQL用户（抽象产品A的产品2）\nclass CSqlUser : public IUser\n{\npublic:\n    virtual void GetUser()\n    {\n        cout<<\"Sql User\"<<endl;\n    }\n    virtual void InsertUser()\n    {\n        cout<<\"Sql User\"<<endl;\n    }\n};\n\n//SQL部门类（抽象产品B的产品2）\nclass CSqlDepartment: public IDepartment\n{\npublic:\n    virtual void GetDepartment()\n    {\n        cout<<\"sql getDepartment\"<<endl;\n    }\n    virtual void InsertDepartment()\n    {\n        cout<<\"sql insertdepartment\"<<endl;\n    }\n};\n\n//抽象工厂\nclass IFactory\n{\npublic:\n    virtual IUser* CreateUser()=0;\n    virtual IDepartment* CreateDepartment()=0;\n};\n\n//ACCESS工厂\nclass AccessFactory : public IFactory\n{\npublic:\n    virtual IUser* CreateUser()\n    {\n        return new  CAccessUser();\n    }\n    virtual IDepartment* CreateDepartment()\n    {\n        return new CAccessDepartment();\n    }\n};\n\n//SQL工厂\nclass SqlFactory : public IFactory\n{\npublic:\n    virtual IUser* CreateUser()\n    {\n        return new  CSqlUser();\n    }\n\n    virtual IDepartment* CreateDepartment()\n    {\n        return new CSqlDepartment();\n    }\n};\n\n//客户端：\nint main()\n{\n    IFactory* factory= new SqlFactory();\n    IUser* user=factory->CreateUser();\n    IDepartment* depart = factory->CreateDepartment();\n\n    user->GetUser();\n    depart->GetDepartment();\n    return 0;\n}\n```\n### 四、建造者模式\n**功能：**将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。\n**优缺点：**一个指挥控制全部，可以精细的控制产品的创建过程，系统扩展方便，符合“开闭”。但产品越多越复杂，内部变多，会导致系统变复杂\n**模式应用：**\n很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。\n![](https://i.loli.net/2019/06/12/5d00f251503d917985.png)\n**举例：** KFC套餐\n套餐是一个复杂对象，一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、 可乐等）等部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。\n![](https://i.loli.net/2019/06/12/5d00f287de42455379.png)\n```\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//最终的产品类\nclass Product \n{\nprivate:\n    vector<string> m_product;\npublic:\n    void Add(string strtemp)\n    {\n        m_product.push_back(strtemp);\n    }\n    void Show()\n    {\n        vector<string>::iterator p=m_product.begin();\n        while (p!=m_product.end())\n        {\n            cout<<*p<<endl;\n            p++;\n        }\n    }\n};\n\n//建造者基类\nclass Builder\n{\npublic:\n    virtual void BuilderA()=0;\n    virtual void BuilderB()=0;\n    virtual Product* GetResult()=0;\n};\n\n//第一种建造方式\nclass ConcreteBuilder1 : public Builder\n{\nprivate:\n    Product* m_product; //体现依赖关系\npublic:\n    ConcreteBuilder1()\n    {\n        m_product=new Product();\n    }\n    virtual void BuilderA()\n    {\n        m_product->Add(\"one\");\n    }\n    virtual void BuilderB()\n    {\n        m_product->Add(\"two\");\n    }\n    virtual Product* GetResult()\n    {\n        return m_product;\n    }\n};\n\n//第二种建造方式\nclass ConcreteBuilder2 : public Builder\n{\nprivate:\n    Product * m_product;  //体现依赖关系\npublic:\n    ConcreteBuilder2()\n    {\n        m_product=new Product();\n    }\n    virtual void BuilderA()\n    {\n        m_product->Add(\"A\");\n    }\n    virtual void BuilderB()\n    {\n        m_product->Add(\"B\");\n    }\n    virtual Product* GetResult()\n    {\n        return m_product;\n    }\n};\n\n//指挥者类\nclass Direct\n{\npublic:\n    void Construct(Builder* temp) //构建一个使用Builder接口的对象\n    {\n        temp->BuilderA();\n        temp->BuilderB();\n    }\n};\n\n//客户端\nint main()\n{\n    Direct *p=new Direct();\n    Builder* b1=new ConcreteBuilder1();\n    Builder* b2=new ConcreteBuilder2();\n\n    p->Construct(b1);                 //调用第一种建造方式\n    Product* pb1 = b1->GetResult();\n    pb1->Show();\n\n    p->Construct(b2);                 //调用第二种建造方式\n    Product * pb2 = b2->GetResult();\n    pb2->Show();\n    return 0;\n}\n```\n\n### 五、原型模式\n**功能：**用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象创建另外一个可定制的对象，而且不需知道任何创建的细节。\n>java java.lang.Cloneable 接口\n>c# ICloneable 接口\n\n![](https://i.loli.net/2019/06/12/5d00f2e2e850613476.png)\n```\n#include<iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n//抽象基类\nclass Prototype  \n{ \nprivate:\n    string m_strName;\n\npublic: \n    Prototype(string strName){ m_strName = strName; }\n    Prototype() { m_strName = \" \"; }\n    void Show() \n    {\n        cout<<m_strName<<endl;\n    }\n    virtual Prototype* Clone() = 0 ; //关键就在于这样一个抽象方法\n} ; \n\n// class ConcretePrototype1 \nclass ConcretePrototype1 : public Prototype \n{ \npublic: \n    ConcretePrototype1(string strName) : Prototype(strName){}\n    ConcretePrototype1(){}\n\n    virtual Prototype* Clone() \n    { \n        ConcretePrototype1 *p = new ConcretePrototype1() ; \n        *p = *this ;                         //复制对象 \n        return p ; \n    } \n} ; \n\n// class ConcretePrototype2 \nclass ConcretePrototype2 : public Prototype \n{ \npublic: \n    ConcretePrototype2(string strName) : Prototype(strName){}\n    ConcretePrototype2(){}\n\n    virtual Prototype* Clone() \n    { \n        ConcretePrototype2 *p = new ConcretePrototype2() ; \n        *p = *this ; //复制对象 \n        return p ; \n    } \n} ; \n\n\n//客户端\nint main()\n{\n    ConcretePrototype1* test = new ConcretePrototype1(\"小王\");\n    ConcretePrototype2* test2 = (ConcretePrototype2*)test->Clone();\n    test->Show();\n    test2->Show();\n    return 0;\n}\n```","tags":["设计模式"],"categories":["设计模式"]},{"title":"设计模式之创建型","url":"/设计模式/设计模式总结_1/","content":"有三个原则：单一职责，开放封闭，依赖倒转。\n## 何谓创建型模式?\n**创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。创建型模式通过以某种方式控制对象的创建来解决问题。**\n##### 1.创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。\n##### 2.创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。\n### 一、单例模式\n**目的：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n**举例：**\n　　在OS中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。\n ![](https://i.loli.net/2019/06/12/5d00ef8b776e039846.png)\n ```\npackage 单例模式;\n\npublic class Singleton {\n\tprivate static Singleton instance;\n\tSingleton() {\n\t\t\n\t}\n\tpublic Singleton GetInstance()\n\t{\n\t\tif(instance == null)\n\t\t{\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\t\n}\npackage 单例模式;\n\npublic class Client {\n  public static void main(String[] args)\n  {\n\t  Singleton singleton = new Singleton();\n\t  Singleton s1 = singleton.GetInstance();\n\t  Singleton s2 = singleton.GetInstance();\n\t  Singleton s3 = new Singleton();\n\t  if(s1==s2)System.out.println(\"s1==s2\");\n\t  if(s1==s3)System.out.println(\"s1==s3\");\n  }\n}\n\n\nResult: s1==s2\n ```\n### 二、工厂方法模式\n**原理:**定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\n```\n#include <string>\n#include <iostream>\nusing namespace std;\n\n//实例基类，相当于Product(为了方便，没用抽象)\nclass LeiFeng\n{\npublic:\n    virtual void Sweep()\n    {\n        cout<<\"雷锋扫地\"<<endl;\n    }\n};\n\n//学雷锋的大学生，相当于ConcreteProduct（具体产品1）\nclass Student: public LeiFeng\n{\npublic:\n    virtual void Sweep()\n    {\n        cout<<\"大学生扫地\"<<endl;\n    }\n};\n\n//学雷锋的志愿者，相当于ConcreteProduct（具体产品2）\nclass Volenter: public LeiFeng\n{\npublic :\n    virtual void Sweep()\n    {\n        cout<<\"志愿者\"<<endl;\n    }\n};\n\n-----------------------------\n//工场基类Creator\nclass LeiFengFactory\n{\npublic:\n    virtual LeiFeng* CreateLeiFeng() //返回值体现依赖关系\n    {\n        return new LeiFeng();\n    }\n};\n\n//工场具体类1（创建大学生产品的具体工厂）\nclass StudentFactory : public LeiFengFactory\n{\npublic :\n    virtual LeiFeng* CreateLeiFeng() //返回值体现依赖关系\n    {\n        return new Student();\n    }\n};\n\n//工场具体类2（创建志愿者产品的具体工厂）\nclass VolenterFactory : public LeiFengFactory\n{\npublic:\n    virtual LeiFeng* CreateLeiFeng()\n    {\n        return new Volenter(); //返回值体现依赖关系\n    }\n};\n\n-----------------------------\n//客户端\nint main()\n{\n    LeiFengFactory *sf=new StudentFactory(); //由客户端选创建什么产品\n    LeiFeng *s=sf->CreateLeiFeng();\n    s->Sweep();\n    delete s;\n    delete sf;\n    return 0;\n}\n```\n### 三、抽象工厂模式\n**功能：**提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类。\n**优缺点：**遵循高内聚低耦合的设计目的，但无法避免开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦，或反之）\n**模式应用：**\n　在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。\n\n![](https://i.loli.net/2019/06/12/5d00f0bdba47d87017.png)\n```\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//用户抽象接口(抽象产品A)\nclass IUser\n{\npublic :\n    virtual void GetUser()=0;\n    virtual void InsertUser()=0;\n};\n\n//部门抽象接口(抽象产品B)\nclass IDepartment\n{\npublic:\n    virtual void GetDepartment()=0;\n    virtual void InsertDepartment()=0;\n};\n\n//ACCESS用户（抽象产品A的产品1）\nclass CAccessUser : public IUser\n{\npublic:\n    virtual void GetUser()\n    {\n        cout<<\"Access GetUser\"<<endl;\n    }\n    virtual void InsertUser()\n    {\n        cout<<\"Access InsertUser\"<<endl;\n    }\n};\n\n//ACCESS部门（抽象产品B的产品1）\nclass CAccessDepartment : public IDepartment\n{\npublic:\n    virtual void GetDepartment()\n    {\n        cout<<\"Access GetDepartment\"<<endl;\n    }\n    virtual void InsertDepartment()\n    {\n        cout<<\"Access InsertDepartment\"<<endl;\n    }\n};\n\n//SQL用户（抽象产品A的产品2）\nclass CSqlUser : public IUser\n{\npublic:\n    virtual void GetUser()\n    {\n        cout<<\"Sql User\"<<endl;\n    }\n    virtual void InsertUser()\n    {\n        cout<<\"Sql User\"<<endl;\n    }\n};\n\n//SQL部门类（抽象产品B的产品2）\nclass CSqlDepartment: public IDepartment\n{\npublic:\n    virtual void GetDepartment()\n    {\n        cout<<\"sql getDepartment\"<<endl;\n    }\n    virtual void InsertDepartment()\n    {\n        cout<<\"sql insertdepartment\"<<endl;\n    }\n};\n\n//抽象工厂\nclass IFactory\n{\npublic:\n    virtual IUser* CreateUser()=0;\n    virtual IDepartment* CreateDepartment()=0;\n};\n\n//ACCESS工厂\nclass AccessFactory : public IFactory\n{\npublic:\n    virtual IUser* CreateUser()\n    {\n        return new  CAccessUser();\n    }\n    virtual IDepartment* CreateDepartment()\n    {\n        return new CAccessDepartment();\n    }\n};\n\n//SQL工厂\nclass SqlFactory : public IFactory\n{\npublic:\n    virtual IUser* CreateUser()\n    {\n        return new  CSqlUser();\n    }\n\n    virtual IDepartment* CreateDepartment()\n    {\n        return new CSqlDepartment();\n    }\n};\n\n//客户端：\nint main()\n{\n    IFactory* factory= new SqlFactory();\n    IUser* user=factory->CreateUser();\n    IDepartment* depart = factory->CreateDepartment();\n\n    user->GetUser();\n    depart->GetDepartment();\n    return 0;\n}\n```\n### 四、建造者模式\n**功能：**将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。\n**优缺点：**一个指挥控制全部，可以精细的控制产品的创建过程，系统扩展方便，符合“开闭”。但产品越多越复杂，内部变多，会导致系统变复杂\n**模式应用：**\n很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。\n![](https://i.loli.net/2019/06/12/5d00f251503d917985.png)\n**举例：** KFC套餐\n套餐是一个复杂对象，一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、 可乐等）等部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。\n![](https://i.loli.net/2019/06/12/5d00f287de42455379.png)\n```\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n//最终的产品类\nclass Product \n{\nprivate:\n    vector<string> m_product;\npublic:\n    void Add(string strtemp)\n    {\n        m_product.push_back(strtemp);\n    }\n    void Show()\n    {\n        vector<string>::iterator p=m_product.begin();\n        while (p!=m_product.end())\n        {\n            cout<<*p<<endl;\n            p++;\n        }\n    }\n};\n\n//建造者基类\nclass Builder\n{\npublic:\n    virtual void BuilderA()=0;\n    virtual void BuilderB()=0;\n    virtual Product* GetResult()=0;\n};\n\n//第一种建造方式\nclass ConcreteBuilder1 : public Builder\n{\nprivate:\n    Product* m_product; //体现依赖关系\npublic:\n    ConcreteBuilder1()\n    {\n        m_product=new Product();\n    }\n    virtual void BuilderA()\n    {\n        m_product->Add(\"one\");\n    }\n    virtual void BuilderB()\n    {\n        m_product->Add(\"two\");\n    }\n    virtual Product* GetResult()\n    {\n        return m_product;\n    }\n};\n\n//第二种建造方式\nclass ConcreteBuilder2 : public Builder\n{\nprivate:\n    Product * m_product;  //体现依赖关系\npublic:\n    ConcreteBuilder2()\n    {\n        m_product=new Product();\n    }\n    virtual void BuilderA()\n    {\n        m_product->Add(\"A\");\n    }\n    virtual void BuilderB()\n    {\n        m_product->Add(\"B\");\n    }\n    virtual Product* GetResult()\n    {\n        return m_product;\n    }\n};\n\n//指挥者类\nclass Direct\n{\npublic:\n    void Construct(Builder* temp) //构建一个使用Builder接口的对象\n    {\n        temp->BuilderA();\n        temp->BuilderB();\n    }\n};\n\n//客户端\nint main()\n{\n    Direct *p=new Direct();\n    Builder* b1=new ConcreteBuilder1();\n    Builder* b2=new ConcreteBuilder2();\n\n    p->Construct(b1);                 //调用第一种建造方式\n    Product* pb1 = b1->GetResult();\n    pb1->Show();\n\n    p->Construct(b2);                 //调用第二种建造方式\n    Product * pb2 = b2->GetResult();\n    pb2->Show();\n    return 0;\n}\n```\n\n### 五、原型模式\n**功能：**用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象创建另外一个可定制的对象，而且不需知道任何创建的细节。\n>java java.lang.Cloneable 接口\n>c# ICloneable 接口\n\n![](https://i.loli.net/2019/06/12/5d00f2e2e850613476.png)\n```\n#include<iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n//抽象基类\nclass Prototype  \n{ \nprivate:\n    string m_strName;\n\npublic: \n    Prototype(string strName){ m_strName = strName; }\n    Prototype() { m_strName = \" \"; }\n    void Show() \n    {\n        cout<<m_strName<<endl;\n    }\n    virtual Prototype* Clone() = 0 ; //关键就在于这样一个抽象方法\n} ; \n\n// class ConcretePrototype1 \nclass ConcretePrototype1 : public Prototype \n{ \npublic: \n    ConcretePrototype1(string strName) : Prototype(strName){}\n    ConcretePrototype1(){}\n\n    virtual Prototype* Clone() \n    { \n        ConcretePrototype1 *p = new ConcretePrototype1() ; \n        *p = *this ;                         //复制对象 \n        return p ; \n    } \n} ; \n\n// class ConcretePrototype2 \nclass ConcretePrototype2 : public Prototype \n{ \npublic: \n    ConcretePrototype2(string strName) : Prototype(strName){}\n    ConcretePrototype2(){}\n\n    virtual Prototype* Clone() \n    { \n        ConcretePrototype2 *p = new ConcretePrototype2() ; \n        *p = *this ; //复制对象 \n        return p ; \n    } \n} ; \n\n\n//客户端\nint main()\n{\n    ConcretePrototype1* test = new ConcretePrototype1(\"小王\");\n    ConcretePrototype2* test2 = (ConcretePrototype2*)test->Clone();\n    test->Show();\n    test2->Show();\n    return 0;\n}\n```","tags":["设计模式"],"categories":["设计模式"]},{"title":"设计模式实践_FPS游戏","url":"/设计模式/设计模式实践FPS游戏/","content":"\n\n### 一、地图切换；   --抽象工厂模式\n每个地图是一个工厂，每个地图中的不同场景，敌人等等的是一个个的产品\n\n人物移动；\n人物状态：生存/死亡    -- 状态模式 \n\n\n### 二、服装设计；  ---建造者模式","tags":["设计模式"],"categories":["设计模式"]},{"title":"排序算法（插入、）","url":"/数据结构/数据结构-排序算法/","content":"### 一、插入排序\n#### 1.是一种简单直观且稳定的排序算法。\n#### 2.原理：将每个序列分为有序序列和无序序列，每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。\n#### 3.时间复杂度为**O(n<sup>2</sup>)**\n ```\n void InsertSort(int r[],int n)\n{\n\n    for(int i=2 ;i<n;i++)\n    {  \n        int j;\n        r[0]=r[i];     //目前无序序列的第一个数据放到r[0]\n        for(j=i-1;r[0]<r[j];j--)  //从r[1]这个序列开始排序，r[0]挨个从有序序列的最后一个往前一个个比较\n        r[j+1]=r[j];\n        r[j+1] = r[0];   //比较完了，将目标数据插入到有序序列相应位置\n    }\n}\n\nint main(){\n int a[11] = {0,4,1,5,6,3,2,8,7,9,10};\n    InsertSort(a,11);\n    for(int i =1 ;i < 11;i++)\n    cout<<a[i]<<\"  \";\n}\n\n ```\n ![](https://i.loli.net/2019/06/11/5cfefbfbbf55d37847.png)\n### 二、希尔排序\n#### 1.希尔排序(Shell's Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。\n#### 2.是对插入排序的改进，在插入排序中是以1为增量让有序序列的第一个值挨个和有序序列的进行比较希尔排序额中是以d为增，d慢慢减小到1，这个过程中不断让每一次排序的所用的比较次数减少。\n#### 3.希尔排序是对直接插入排序的一种优化，可以用于大型的数组，希尔排序比插入排序和选择排序要快的多，并且数组越大，优势越大。\n#### 4.时间复杂度 ：O(n<sup>1.3</sup>)\n```\nvoid HillSort(int r[],int n)\n{\n    int i,j;\n    for(int d=n/2 ; d>=1; d=d/2)   //以d位增量来插入\n    {\n\n        for(i=d+1;i<=n;i++)\n        {\n            r[0]=r[i];\n            for(j=i-d;j>0&&r[0]<r[j];j-=d)\n            {\n                r[j+d]=r[j];\n            }\n            r[j+d]=r[0];\n        }\n    }\n}\n\nint main(){\n\n int a[11] = {0,4,1,5,6,3,2,8,7,9,10};\n    HillSort(a,11);\n    for(int i =1 ;i < 11;i++)\n    cout<<a[i]<<\"  \";\n    return 0;\n}\n```\n![](https://i.loli.net/2019/06/11/5cfeffef648f129548.png)\n### 三、冒泡排序（双向排序）+ 双向冒泡排序\n>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。\n它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。\n这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。\n\n#### 冒泡排序算法的原理如下：\n#### 1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n#### 2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。\n#### 3.针对所有的元素重复以上的步骤，除了最后一个。\n#### 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n#### 3.时间复杂度O(n²)\n```\nvoid BubbleSort(int a[],int n)\n{\n    int bound;\n    int exchange = n;  //有序序列第一个值为最后一个值\n    while(exchange!=0)\n    {\n       bound =  exchange ;   //有序序列第一个值\n       exchange  = 0;     //exchange=0 如果下面的循环中的判断成立，也就是无序序列确实是无序，则while循环继续。\n       for(int i =0 ;i<bound;i++)\n       {\n\n           if(a[i]>a[i+1])\n           {\n               int temp = a[i];\n               a[i] = a[i+1];\n               a[i+1] = temp;\n               exchange = i ;  //for循环截至是，exchange就是有序序列的第一个值\n           }\n       }\n\n    }\n}\n\nvoid DoubleBubbleSort(int a[],int n)\n{\n  int low = 0,high;\n  high =n-1;\n  int lastPos;\n  while(low<high)\n  {\n       lastPos = high;\n       for(int i=low;i<lastPos;i++)\n       {\n           if(a[i]>a[i+1])\n           {\n               int  temp = a[i];\n               a[i]= a[i+1];\n               a[i+1] = temp;\n               high = i;\n           }\n       }\n       if(high==lastPos)  //没有交换位置\n       {\n           break;\n       }\n       lastPos = low;\n       for(int i=high-1;i>lastPos;i--)\n       {\n           if(a[i]>a[i+1])\n           {\n               int  temp = a[i];\n               a[i]= a[i+1];\n               a[i+1] = temp;\n               low = i;\n           }\n\n       }\n        if(low==lastPos)  //没有交换位置\n       {\n           break;\n       }\n  }\n\n}\nint main(){\n\n    int a[11] = {0,1,4,5,6,3,2,8,7,9,10};\n    BubbleSort(a,11);\n    cout<<\"冒泡排序: \";\n    for(int i =0 ;i < 11;i++)\n    cout<<a[i]<<\"  \";\n    cout<<endl;\n     int b[11] = {0,1,4,5,6,3,2,8,10,7,9};\n     DoubleBubbleSort(b,11);\n     cout<<\"双向冒泡排序：\";\n      for(int i =0 ;i < 11;i++)\n    cout<<b[i]<<\"  \";\nreturn 0;\n\n}\n```\n![](https://i.loli.net/2019/06/11/5cff018c3521a47453.png)\n\n### 四、快速排序\n>快速排序（Quicksort）是对冒泡排序的一种改进。\n快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n#### 1.时间性能：O(N\\*log<sub>2</sub>N)\n```\n// Partition一次排序，每一次都找到一个轴值\nint Partition(int a[],int f,int e)\n{\n    int i = f ,j=e;\n    while(i<j)\n    {\n\n        while(i<j&&a[i]<=a[j])j--;\n        if(i<j){\n            int temp = a[i];\n            a[i]=a[j];\n            a[j] =temp;\n            i++;\n\n        }\n\n         while(i<j&&a[i]<=a[j])i++;\n          if(i<j){\n            int temp = a[i];\n            a[i]=a[j];\n            a[j] =temp;\n            j--;\n\n        }\n        for(int i =0 ;i < 11;i++)\n    cout<<a[i]<<\"  \";\n    cout<<endl;\n\n    }\n    cout<<\"轴值：\"<<i<<\";  \";\n      for(int i =0 ;i < 11;i++)\n    cout<<a[i]<<\"  \";\n    cout<<endl;\n        return i;\n}\n//挨个找轴值，找到序列长度为1的轴值，排序就结束了\nvoid QuickSort(int a[],int f,int e)\n{\n\n    if(f<e)\n    {\n       int p = Partition(a,f,e);\n        QuickSort(a,f,p-1);\n    QuickSort(a,p+1,e);\n    }\n}\nint main(){\n\nint a[11] = {0,4,1,5,6,3,2,8,7,9,10};\n    QuickSort(a,0,11);\n    for(int i =0 ;i < 11;i++)\n    cout<<a[i]<<\"  \";\n    return 0;\n}\n```\n![](https://i.loli.net/2019/06/11/5cff06c07b8ba43218.png)","tags":["数据结构"],"categories":["数据结构"]},{"title":"Unity-储存游戏数据的方式","url":"/unity/Unity-储存游戏数据的方式/","content":"<escape> Unity 储存游戏数据的方式<!--more--></escape>\n### 一、本地化txt文件\n#### 在本地的Application.path路径中：\n1.Application.persistentDataPath 持久数据路径,APP更新时不会删除此数据 \n2.Application.dataPath 数据路径(Assets目录)  例：E:/Work/cosmosbox/cb-client/\n3.AssetsApplication.streamingAssetsPath (Assets/StreamingAssets目录),AssetBundle一般存放在此目录下,可以通过www读取 \n4.Application.temporaryCachePath 操作系统的临时缓存目录 ，例： Z:/TEMP/Cosmosbox/ [我的电脑把缓存文件设置在Z盘]\n#### io流输入输出用C#的 //TODO 补充C#io流\n\n```\nString filename;\nString path;\nif (!File.Exists(path+filename))\n{\n   Directory.CreateDirectory(path);    //创建一个文件夹\n   FIleStream fsl = new FileStream(path+filename, FileMode.Create, FileAccess.Write);  //创建一个可读写的文件\n}\n//1.读操作\nStreamReader sw = new StreamReader(path+filename);\nString str = sw.ReadLine();\nsw.close();\n//2.写操作\nStreamWriter sw = new StreamWriter(path+filename);\nsw.WriteLine(str);\nsw.close();\n\n```\n\n### 二、放到 PlayerPrefs 中\n1、Unity3D中的数据持久化是以键值的形式存储的，可以看作是一个字典。\n2、Unity3D中值是通过键名来读取的，当值不存在时，返回默认值。\n在Unity3D中只支持int、string、float三种数据类型的读取.\n```\nSetInt(key);SetFloat(key);SetString(key);\nGetInt(key);GetFloat(key);GetString(key);\nDelteAll();\nDeletKey(key);\nHasKey(key);\n```\n持久化，一般是放不变的数据\n\n### 三、Json+数据加密\n\n#### 1.Json\n##### （1). Unity自带的Unity\n```\ncalss Student{}\nStudent m;\nJsonUtility.ToJson(m);\nString str;  //Json字符串\n(Student)JsonUtility.FromJson<Student>(str);\n```\n##### (2).SimpleJson \n[点我]()\n","tags":["unity"],"categories":["unity"]},{"title":"unity canvas","url":"/unity/unity_canvas/","content":"<escape> Canvas<!--more--></escape>\n## 画布（Canvas）\n　Canvas画布是承载所有UI元素的区域。Canvas实际上是一个游戏对象上绑定了Canvas组件。所有的UI元素都必须是Canvas的自对象。如果场景中没有画布，那么我们创建任何一个UI元素，都会自动创建画布，并且将新元素置于其下。\n \n ### 一、渲染模式\n #### 1.Screen Space-Overlay模式\n Screen Space-Overlay（屏幕控件-覆盖模式）的画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层，或者说画布的画面永远“覆盖”其他普通的3D画面，如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕。\nScreen Space-Overlay模式的画布有Pixel Perfect和Sort Layer两个参数：\n　　（1）Pixel Perfect：只有RenderMode为Screen类型时才有的选项。使UI元素像素对应，效果就是边缘清晰不模糊。\n　　（2）Sort Layer: Sort Layer是UGUI专用的设置，用来指示画布的深度。\n ####  2.Screen Space-Camera\n （屏幕空间-摄影机模式）和Screen Space-Overlay模式类似，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来 绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。在此模式下，UI元素是由perspective也就是视角设定的，视角广度由Filed of View设置。\n\n　　这种模式可以用来实现在UI上显示3D模型的需求，比如很多MMO游戏中的查看人物装备的界面，可能屏幕的左侧有一个运动的3D人物，左侧是一些UI元素。通过设置Screen Space-Camera模式就可以实现上述的需求。\n  　它比Screen Space-Overlay模式的画布多了下面几个参数：\n\n　　（1）Render Camera:渲染摄像机\n\n　　（2）Plane Distance:画布距离摄像机的距离\n\n　　（3）Sorting Layer: Sorting Layer是UGUI专用的设置，用来指示画布的深度。可以通过点击该栏的选项，在下拉菜单中点击“Add Sorting Layer”按钮进入标签和层的设置界面，或者点击导航菜单->edit->Project Settings->Tags and Layers进入该页面。\n\n　　　　可以点击“+”添加Layer，或者点击“-”删除Layer。画布所使用的Sorting Layer越排在下面，显示的优先级也就越高。\n\n　　（4）Order in Layer:在相同的Sort Layer下的画布显示先后顺序。数字越高，显示的优先级也就越高。\n ####  3.World Space\n World Space即世界控件模式。在此模式下，画布被视为与场景中其他普通游戏对象性质相同的类似于一张面片（Plane）的游戏物体。画布的尺寸可以通过RectTransform设置，所有的UI元素可能位于普通3D物体的前面或者后面显示。当UI为场景的一部分时， 　　可以使用这个模式。\n\n　　它有一个单独的参数Event Camera，用来指定接受事件的摄像机，可以通过画布上的GraphicRaycaster组件发射射线产生事件。\n\n　　这种模式可以用来实现跟随人物移动的血条或者名称。\n  我们通过下面的表格可以对比一下三种渲染模式的区别：\n![](https://i.loli.net/2019/06/11/5cfef0be64b0891326.png)\n### //TODO Screen Match mode\n\n","tags":["unity"],"categories":["unity"]},{"title":"Oracle--上机实验2","url":"/Oracle/oracle实验2/","content":"<escape>程序块，程序包 <!--more--> <escape>\n第一步：建表：\n```\ndrop table emp;\ndrop table dept;\ncreate table dept(\n       deptno number(10) primary key,\n       dname varchar2(30),\n       loc varchar2(30)\n)\ncommit;\n```\n```\ncreate table emp(\n       empno number(10) primary key,\n       ename varchar2(30),\n       job varchar2(30),\n       mgr varchar2(30),\n       hiredate number(10),\n       sal number(10),\n       comm number(10),\n       deptno number(10),\n       foreign key(deptno) references dept(deptno)\n)\n```\n第二步：向各表中插入数据：\n```\ninsert into dept values(1, '技术部' ,'南泥湾');\ninsert into dept values(2, 'SALES' ,'深圳市');\ninsert into dept values(3, '事业部' ,'北京市');\ninsert into dept values(4, '服务部' ,'延安');\ninsert into dept values(5, '生产部' ,'南京市');\ninsert into dept values(6, '宣传部' ,'上海市');\ninsert into dept values(7, '打杂部' ,'广州市');\ninsert into dept values(8, '司令部' ,'重庆市');\ninsert into dept values(9, '卫生部' ,'长沙市');\ninsert into dept values(10, '文化部' ,'武冈市');\ninsert into dept values(11, '娱乐部' ,'纽约');\ninsert into dept values(12, '管理部' ,'伦敦');\ninsert into dept values(13, '行政部' ,'天津市');\nselect * from dept;\n````\n```\ninsert into emp values(1, '关羽羽', 'CLERK' ,'刘备备', 20011109, 2000, 1000, 3);\ninsert into emp values(2, 'SMITH', 'CLERK' ,'刘备备', 20120101, 2000, 800, 6);\ninsert into emp values(3, '刘备备', 'MANAGER' ,'宋祖英', 20080808, 9000, 4000, 3);\ninsert into emp values(4, 'TOM', 'ENGINEER' ,'Steve', 20050612, 3000, 1000, 1);\ninsert into emp values(5, 'Steve', 'MANAGER' ,'宋祖英', 20110323, 80000, 9000, 1);\ninsert into emp values(6, '张飞飞', 'CLERK' ,'刘备备', 20101010, 2000, 1000, 3);\ninsert into emp values(7, 'SCOTT', 'CLERK' ,'刘备备', 20071204, 2000, 1000, 3);\ninsert into emp values(8, '宋祖英', 'Boss' ,'无', 20060603, 2000, 1000, 8);\ninsert into emp values(9, '曹仁人', 'SALESMAN' ,'曹操操', 20120130, 2000, 1000, 2);\ninsert into emp values(10, '曹操操', 'MANAGER' ,'宋祖英',20090815, 2000, 1000, 2);\ninsert into emp values(11, '酱油哥', 'HAPI' ,'XXX',20090215, 3, 1, 2);\n```\n\n游标更新操作 将所有工资位1000以下的变成1500 所有大于1000的乘以1.5 所有大于10000的变成10000\n```\nSET ServerOutput ON;\nDeclare \n  cursor c_1 is \n         select empno,sal from emp\n         for update of sal nowait;\n  v_sal emp.sal%type;\n  \nBegin\n  for v_1 in c_1 \n    Loop\n      if(v_1.sal<=1000) then v_sal:=1500;\n      else \n        v_sal :=v_1.sal*1.5;\n        if(v_sal>10000)then v_sal := 10000;\n      end if;\n    end if;\n    update emp set sal=v_sal where current of c_1;\n    end loop;\nend;\n```\n\n\n程序过程\n：\n\n1.简单的procedure\n```\n select empno,ename from emp;\n\nSET ServerOutput ON;\ncreate or replace procedure update_emp as\n\nbegin\n  update emp set ename='关羽' where empno =1; \nend update_emp;\n\nBegin \n  update_emp();\nEnd;\n```\n2.有程序包的procedure\n```\ncreate or replace package test1 \nis\n  procedure t1;\n  procedure t2;\n  function t3 return number;\n\nend test1;\n```\n```\ncreate or replace package body test1 \n\nas\n    procedure t1  as \n         begin    \n          \n    DBMS_OUTPUT.PUT_LINE(sysdate);\n         end;\n    procedure t2 as\n      begin\n         update emp set ename='关羽' where empno =1;\n         end;\n    function t3  return number is\n      begin\n         return 1;\n         end;\n         \nend test1;\nextc test1.t1;\n```\n```\nSET ServerOutput ON;\nBegin \n  test1.t1();\nEnd;\nSET ServerOutput ON;\nBegin \n  test1.t2();\nEnd;\nSET ServerOutput ON;\nBegin \n  test1.t3();\nEnd;\n```\n\n\nselect avg(sal),count(*) from emp;\n\n1.程序块 找出deptno=？ 的平均工资和人数\n```\ncreate or replace procedure return_deptinfo\n(\n p_deptno in emp.deptno%type,\n p_avgsal out emp.sal%type,\n p_count out emp.sal%type\n\n)\nas\nbegin\n    select avg(sal),count(*)  into p_avgsal,p_count from emp\n    where\n    deptno = p_deptno ;\nend return_deptinfo;\n```\n\n```\n\nSET ServerOutput ON;\nDeclare \n   p_deptno  emp.deptno%type := 1;\n   p_avgsal  emp.sal%type;\n   p_count  emp.sal%type;\nBegin \n  return_deptinfo(p_deptno,p_avgsal,p_count);\n   DBMS_OUTPUT.PUT_LINE(p_avgsal||';'||p_count);\nEnd;\n```\n2.找到no中比平均工资高的员工并显示出来\n```\ncreate or replace procedure show_emp\n(\n p_deptno in emp.deptno%type\n)\nas\nv_sal emp.sal%type;\nBegin\n   select avg(sal) into v_sal from emp where deptno = p_deptno;\n   DBMS_OUTPUT.PUT_LINE(p_deptno||'的平均工资：'||v_sal);\n   \n     DBMS_OUTPUT.PUT_LINE('P_deptno为'||p_deptno||'中比平均工资高的');\n   for v_emp in(select * from emp where\n      deptno=p_deptno AND sal>v_sal )\n      Loop\n        DBMS_OUTPUT.PUT_LINE('empno：'||v_emp.empno||'name： '||v_emp.ename);\n      end Loop;\nend show_emp;\nSET ServerOutput ON;\nDeclare \n   p_deptno  emp.deptno%type := 1;\n  Begin  \n    show_emp(p_deptno);\n    End;\n```\n\n","tags":["Oracle"],"categories":["Oracle"]},{"title":"Oracle--上机实验1","url":"/Oracle/oracle实验/","content":"<escape>建表。。。。游标的使用 <!--more--> <escape>\n\n\n```\nselect tablespace_name as 表空间名,SUM(bytes)\nfrom dba_data_files\ngroup by tablespace_name;\n```\n\n```\ncreate table t_stu(  \n  stuid      number(10)   primary key not null,  \n  stuname    varchar2(20) not null,  \n  stusex     varchar2(2)  default '男' check(stusex in('男','女'))\n)TABLESPACE T1; \n```\n```\ncreate table xs(  \n   xh      varchar2(26)   primary key not null ,\n   xs_name varchar2(20)   not null,\n   sex     varchar2(2)    default '男' check(sex in('男','女'))\n)TABLESPACE T1; \n```\n```\ninsert  into xs(xh,xs_name,sex) values(20171746,'虞启贤','男');\ninsert  into xs(xh,xs_name,sex) values(20171828,'张雪微','女');\ninsert  into xs(xh,xs_name,sex) values(20171755,'花解语','女');\ninsert  into xs(xh,xs_name,sex) values(20171745,'叶伏天','男');\n```\n```\nalter table 表名 add constraint 约束名 约束内容。\nfor example:\nalter table xs add constraint pk primaey key xh;\nalter table xs add constraint ck     check(sex=='男'or sex =='女');  //and or \nalter table xs add constraint un_xh unique(xh); //列值唯一\n-增加主键     \nalter table 表名 add constraint 主键名 primary key (字段名1);\n-增加外键:     \nalter table 表名 add constraint 外键名 foreign key (字段名1) references 关联表 (字段名2);\nalter table xs move tablespace T2;         //  将xs表从表空间t1转移到t2；\nalter table xs modify(sex default '男') ;  // 修改sex列的默认值\ndrop table t_stu;                        //删除表\n \n CREATE PUBLIC SYNONYM x FOR xs;  //增加同义词 \n DROP SYNONYM s_dept;\n ```\n \n ```\n 1.修改列的长度  \n      alter table dept modify loc varchar2(50);\n  \n2. 修改列的精度  \n      alter table employee_info modify empno number(2);\n  \n3. 修改列的数据类型  \n      alter table employee_info modify sex char(2); \n \n4. 修改默认值  \n      alter table employee_info modify hiredate default sysdate+1; \n \n5.禁用约束  \n  alter table employee_info disable constraint uq_emp_info;\n  \n6.启用约束  \n  alter table employee_info enable constraint uq_emp_info;  \n7.延迟约束  \n  alter table employee_info drop constraint fk_emp_info;  \n  alter table employee_info add constraint fk_emp_info foreign key(deptno)  \n        references dept(deptno)  \n  deferrable initially deferred;  \n8.向表中添加注释  \n  comment on table employee_info is 'information of employees';\n  \n9.向列添加注释  \n  comment on column employee_info.ename is 'the name of employees';  \n  comment on column dept.dname is 'the name of department';  \n10.清除表中所有数据  \n  truncate table employee_info; (DELETE FROM table_name或DELETE * FROM table_name) \n```\n\n```\ndeclare \n var sex :='男';\n v_sex xs%rowtype\nbegin\n select * into x_sex form xs so\n where so.sex=sex;\n ```\n \n游标的使用：\n游标的属性   返回值类型   意    义   \n%ROWCOUNT   整型  获得FETCH语句返回的数据行数   \n%FOUND  布尔型 最近的FETCH语句返回一行数据则为真，否则为假   \n%NOTFOUND   布尔型 与%FOUND属性返回值相反   \n%ISOPEN 布尔型 游标已经打开时值为真，否则为假  \n简单使用：\n```\nDECLARE \n  v_xh NUMBER;\n  v_name VARCHAR2(26);\n  Cursor Mycur IS\n  Select xh,xs_name from xs \n  where xh=20171746\n  ;\nBegin \n   \n   open Mycur ;\n   Fetch Mycur into v_xh,v_name ; \n   close Mycur;\n   \n   dbms_output.put_line('学生学号：'||v_xh||' 学生姓名:'||v_name||' 已执行的数据行数：');\n   \nEnd;\n```\n1.隐式使用游标\n```\nBegin\n  Update xs set sex='女' where sex = '男';\n  IF SQL%FOUND THEN\n    DBMS_OUTPUT.put_line('成功将男性De改为女性');\n    COMMIT;\n    ELSE\n     DBMS_OUTPUT.put_line('UPDATE 失败'); \n     END IF;\nEND;\n\nUpdate xs set sex='男' where xh=20171746;\nSET serveroutput on;\n```\n2.用rowtype+游标 提取是男性的学生\n```\nDeclare\n     Cursor v_cursor IS\n     select * from xs s where s.sex = '男';\n     v_xs v_cursor%ROWTYPE;  \nBegin\n     IF v_cursor%ISOPEN=false Then\n       open v_cursor;\n      END IF;\n      \n      Fetch  v_cursor into v_xs ;\n      \n      While v_cursor%Found\n        LOOP\n           DBMS_OUTPUT.PUT_LINE('学号：'||v_xs.xh||' 姓名：'||v_xs.xs_name||' 性别：'||v_xs.sex); \n           DBMS_OUTPUT.PUT_LINE('已执行行数:'||v_cursor%rowcount);\n            Fetch  v_cursor into v_xs ;\n        End LOOP;\n        \n        CLOSE v_cursor;  \nEND;\n```\n3.显示学号大小前三的学生\n```\nDeclare \n    Cursor v_c IS\n     select * from xs order BY xh DESC;\n    v_xs v_c%rowtype;\n   \nBEGIN\n  open v_c;\n  \n    FOR I in 1..3 LOOP\n      Fetch v_c into v_xs;\n      dbms_output.put_line('学号：'||v_xs.xh||' 姓名：'||v_xs.xs_name||' 性别：'||v_xs.sex);\n         END LOOP;\n         \n  close v_c;\nEND;\n```\n4.特殊的FOR循环形式\n(1).\n```\nDeclare \n    Cursor v_c IS\n     select * from xs order BY xh DESC;\nBEGIN\n  FOR v_xs in v_c LOOP\n    dbms_output.put_line('学号：'||v_xs.xh||' 姓名：'||v_xs.xs_name||' 性别：'||v_xs.sex);\n   END LOOP;\n  ENd; \n  ```\n(2).\n```\nBEGIN\n  FOR v_xs in (select * from xs order BY xh DESC) LOOP\n    dbms_output.put_line('学号：'||v_xs.xh||' 姓名：'||v_xs.xs_name||' 性别：'||v_xs.sex);\n   END LOOP;\n  ENd; \n  ```\n5.带参数的游标。 \n```\nDeclare\n     Cursor v_c(x_xh Number) IS\n     select * from xs where xh=x_xh ;\n     \n     \n     v_xs v_c%rowtype;\n     \nBEgin\n     open v_c(20171755);\n     Fetch v_c into v_xs;\n     dbms_output.put_line('学号：'||v_xs.xh||' 姓名：'||v_xs.xs_name||' 性别：'||v_xs.sex);\n     close v_c;\nEnd;\n```\n6.游标变量的使用\n(1)\n```\nSET ServerOutput ON;\nDeclare\nType cursor_type is ref cursor;\nc_1 cursor_type;\nr_1 xs%rowtype;\n\nBegin\n  open c_1 For select * from xs where xs.xh='20171746';\n    DBMS_OUTPUT.PUT_LINE('已执行行数:'||c_1%rowcount);\n  while c_1%found Loop\n    fetch c_1 into r_1;\n        DBMS_OUTPUT.PUT_LINE('已执行行数:'||c_1%rowcount);\n       dbms_output.put_line('学号：'||r_1.xh||' 姓名：'||r_1.xs_name||' 性别：'||r_1.sex);\nend loop;\nclose c_1;\nEnd;\n```\n(2)\n```\nSET ServerOutput ON;\nDeclare\nType cursor_type is ref cursor return xs%rowtype;\nc_1 cursor_type;\nr_1 xs%rowtype;\n\nBegin\n  open c_1 For select * from xs;\n    DBMS_OUTPUT.PUT_LINE('已执行行数:'||c_1%rowcount);\nFor i in c_1 Loop\n   dbms_output.put_line('学号：'||i.xh||' 姓名：'||i.xs_name||' 性别：'||i.sex);\nEnd Loop;\n\nclose c_1;\nEnd;\n```\n(3)\n\n \n","tags":["Oracle"],"categories":["Oracle"]},{"title":"Oracle--4","url":"/Oracle/Oracle---4/","content":"<escape> <!--more--> <escape>\n# 一、数据库安全管理\n\n### 1、Oracle认证方法\n 操作系统认证：在cmd下sqlplus / ，则不要要用户名和密码了。\n 还有网络认证和数据库认证\n 数据库管理员认证\n connect as /sysdba\n \n \n 忘记DBA口令是简单修改口令的方法\n ```\n sqlplus as/sysdba\n alter user sus identified by NEWPWD;\n commit;\n conn sys /as sysdba\n ```\n\n\n### 2.用户管理\n#### （1）.创建用户\n```\ncreate user 用户名\nidentified by 口令\ndefault tablespace 默认表空间\ntemporary tablespace 临时表空间\n```\n#### （2）.修改用户\n``` \nalter user 用户名 identified by NEWPWD  //修改密码\n```\n```\nalter user 用户名 password expire/lock/unlock //设置用户密码过期/锁定/解锁\n```\n```\nalter user 用户名 quata 表空间配额大小 on 表空间//位用户分配表空间配额\n```\n```\ndrop user 用户名  //删除用户\n```\n\n### 3.角色管理\n>查看角色 select * from dba_roles;\n\n#### (1).创建角色\n```\ncreate role rolename identified by newwpd;\n```\n#### （2）.指定用户角色\n```\ngrant role to user;   //指定角色\nexample:  grant connect to userman;\nrevoke role from user //回收角色\n```\n#### （3）.修改角色\n```\nalter role rolename not identified //取消rolename角色的密码验证\ndrop role rolename //删除rolename角色\n```\n### 4.权限管理\n\n","tags":["Oracle"],"categories":["Oracle"]},{"title":"Markdown 语法的几个简单使用","url":"/normal/Markdown语法的几个简单使用/","content":"\n---\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题 (几个#号就是几个标题)\n---\n- sdsd\n- sdsd\n- sdsd  (-)\n\n1.ss  \n2.22\n3.33\n\n\n[baidu](www.baidu.com)  \n``` \n([]())\n```\n>sdsdsdsda\n>sdsadsadasd  (>)\n\n*sddsd*\n\n**sdsdsd**\n```\n\n```\n\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n| zebra stripes | are neat      |    $1 |\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n\n![][1]\n[1]: http://latex.codecogs.com/gif.latex?\\prod%20\\(n_{i}\\)+1\n\n\n### 在MarkDown中打出上标、下标、及一些特殊符号\n[链接](https://www.jianshu.com/p/80ac23666a98)\n"},{"title":"Oracle---3","url":"/Oracle/Oracle---3/","content":"\n\n<escape>回滚段的管理、数据库文件管理（控制文件，重做日志文件，归档文件） <!--more--></escape>\n\n## 一、回滚段的管理\n1.查看回滚段\n{% codeblock %}\nCOL 回滚段名 FOR A20\nSELECT\nSEGMENT_NAME 回滚段名 , TABLESPACE_NAME 所在表空间，BYTES 大小\nFROM DBA_SEGMENTS WHERE SEGMENT_TYPE='ROLLBACK';\n{% endcodeblock %}\n![](https://i.loli.net/2019/05/25/5ce8ed98a941589164.png)\n\n还可以使用视图 V$ROLLNAME 和视图 V$ROLLSTAT\n![](https://i.loli.net/2019/05/25/5ce8ee84c4d0230376.png)\n![](https://i.loli.net/2019/05/25/5ce8ee8600acd59452.png)\n\n2.查看和设置回滚段的管理模式\n{% codeblock %}\nSHOW PARAMETER UNDO_MANAGEMENT\n{% endcodeblock %}\n![](https://i.loli.net/2019/05/25/5ce8efc2af30021304.png)\n{% codeblock 将回滚段管理模式设置为手动管理 %}\nalter system set UNDO_MANAGEMENT = MANUAL\nSCOPE = SPFILE;\n{% endcodeblock %}\n\n3.创建回滚段\n{% codeblock %}\nCREATE [PUBLIC] ROLLBACK SEGMENT 回滚段名称\n TABLESPACE T1\n STORAGE 存储选项：{\n inital 5M\n next 2M\n maxextents unlimited\n }\n{% endcodeblock %}\n\n4.修改回滚段的属性\n{% codeblock %}\n1.设置状态\nalter rollback segment 回滚段名称 online\n2.手动收缩回滚段\n3.alter rollback segment 回滚段名称 shrink to 回滚段的初始大小\n{% endcodeblock %}\n5.删除回滚段\n{% codeblock %}\nalter rollback segment 回滚段名称 offline //先脱机\ndrop rollback segment 回滚段名称\n{% endcodeblock %}\n\n---\n## 二、数据库文件管理\n1.SCN(System Change Number）\n(1).控制文件\n```\nselect name from v$controlfile;\n```\n![](https://i.loli.net/2019/05/30/5cefa06f1538063291.png)\n![](https://i.loli.net/2019/05/30/5cefa0d36563426778.png)\n[CREATE CONTROLFILE官方文档](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-CONTROLFILE.html#GUID-9B389F28-C4D0-405D-BFE6-48237E8BD791)\n\n(2).重做日志文档\n```\ncol MEMBER  for A40\nselect GROUP# ,MEMBER  from v$logfile(v$log);\n\n```\n![](https://i.loli.net/2019/05/30/5cefa3ac9b54b80023.png)\n\n(3).归档日志管理\n```\nselect name,log_mode from v$database;\n```\n![](https://i.loli.net/2019/05/30/5cefa6d6ce67c56736.png)\n\n","tags":["Oracle"],"categories":["Oracle"]},{"title":"Oracle---2","url":"/Oracle/Oracle---2/","content":"<escape> 表空间  <!--more--> </escape>\n\n一、查看表空间信息\n{% codeblock %}\nselect * from v$tablespace;\nselect tablespace_name,contents,status from dba_tablespaces;//属性信息\nselect * from dba_segments;//查看段信息；\nselect * from dba_free_space;//查看表空间中空闲区间的信息；\nselect * from dba_data_files;//查询所有数据文件的信息；\n\n{% endcodeblock %}\n![](https://i.loli.net/2019/05/16/5cdd629ca449598241.png)\n![](https://i.loli.net/2019/05/16/5cdd63220fe8f38869.png)\n\n统计表空间的额总空间大小\n{% codeblock %}\n\nselect tablespace_name as 表空间名,SUM(bytes)\nfrom dba_data_files\ngroup by tablespace_name;\n{% endcodeblock %}\n![](/20190516205734005/20190516092249751.png)\n统计表空间的空闲空间大小和表空间的使用情况 P87\n\n\n\n二、创建表空间\nCreate [UNDO] Tablespace 表空间名\n【datafile子句\n【{ MINNUM EXTENT 整数 [k|m]\n| BLOCKSIZE 整数 [k]\n|logging子句\n|FORCE LOGGING\n|DEFAULT{是否压缩数据段}存储子句\n| [online|offline] \n| [permanent|tempopary]\n| 区间管理子句\n| 段管理子句 }】\n{% codeblock 1.创建本地表空间 %}\ncreate tablespace t1 datafile '' size 10G;\n{% endcodeblock %}\n{% codeblock 2.创建大文件表空间 %}\ncreate bigfile tablespace t1 datafile '' size 10G;\n{% endcodeblock %}\n\n{% codeblock 3.创建临时表空间 %}\ncreate temporary tablespace t1 datafile '' size 10M \nreuse\nextent managemant local uniform size 16m;\n{% endcodeblock %}\n{% codeblock 4.定义表空间的段管理方式 %}\ncreate  tablespace t1 datafile '' size 10M \nextent managemant local autoallocate\nsegment space management auto;\n{% endcodeblock %}\n{% codeblock 5.创建撤销表空间 %}\ncreate  undo tablespace t1 datafile '' size 10m reuse;\n{% endcodeblock %}\n\n\n三、设置和修改表空间属性\n {% codeblock 1.重命名表空间 %}\n alter tablespace 表空间名字 rename to 表空间新名字;\n {% endcodeblock %}\n {% codeblock 2.向本地表空间增加数据文件 %}\n alter tablespace t1 add datafile '' size 10m;\n {% endcodeblock %}\n  {% codeblock 3.修改大文件表空间属性 %}\n alter tablespace t1 resize 10G;\n {% endcodeblock %}\n  {% codeblock 4.向临时表空间中添加临时文件 %}\n alter tablespace t1 add tempfile d1 size 10m;\n {% endcodeblock %}\n  {% codeblock 5.设置表空间的状态 %}\n alter tablespace 表空间名字 offline||online||only||write\n {% endcodeblock %}\n \n四、删除表空间\n  {% codeblock  %}\ndrop tablespace t1 including contents and datafiles;\n {% endcodeblock %}\n","tags":["Oracle"],"categories":["Oracle"]},{"title":"Oracle---1","url":"/Oracle/Oracle---1/","content":"<escape>启动EM ，创建数据库，启动数据库，配置情况，维护数据库(shutdown 和 startup)<!--more--> </escape>\n<br>\n一、启动 Oracle Enterprise Manager  \n在确认OracleDBConsoleoracl服务已经启动后后\nhttps:// oracle数据库服务器名称:<Em端口号>/em\nhttps://orcl:1158/em\n\n{% codeblock cmd下 %}\nsqlplus /nolog\nconn /as sysdba\n//nolog下以sysdba身份进入Oracle\nstartup pfile='E:\\app\\ajwlf\\admin\\orcl\\pfile\\init.ora.1282019185223'\n//开启数据库实例\n\n重新启动监听程序。\n\nlsnrctl stop // 关闭\n\nlsnrctl start // 启动\n{% endcodeblock %}\n\n{% codeblock %}\n$select name,created from v$database;\n{% endcodeblock %}\n![](https://i.loli.net/2019/05/16/5cdd53c92abde25018.png)\n{% codeblock %}\n$select * from v$version;  //查看数据库的详细版本信息\n{% endcodeblock %}\n![](https://i.loli.net/2019/05/16/5cdd564a7f41b64286.png)\n\n二、创建数据库\n1. 使用 Database Configuration Assitant 工具创建数据库实例 具体见书的49页\n2. 使用DBCA命令\n3. 创建数据库 书P55\n3. 使用SQL语句创建数据库 ordim -new -sid <实例名> -intpwd OraclePass\n4. 创建文本初始化参数文件（PFILE）\n\n三、删除数据库\n1.Database Configuration Assitant\n2.使用DBCA命令\n3.使用DROP DATABASE 语句删除数据库\n\n\n四、配置情况\n查看初始化参数:\n1.em\n2.SHOW　ＰＡＲＡＭＥＴＥＲ\nＳＨＯＷ PARAMETERS ｄｂ　查看所有以ｄｂ开头的初始化参数\n![](https://i.loli.net/2019/05/16/5cdd5b3603ae862022.png)\n{% codeblock %}\nselect　name,value,display_value from v$parameter\nwhere name like '%db%' ;\n{% endcodeblock %}\n\n\n四、维护数据库\n1.使用shutdown命令关闭数据库实例\n（1）正常关闭:shutdown normal;\n (2) 以处理事务方式来关闭：shutdown transactional;\n (3) 立即关闭： shutdown immediate\n (4) 中止关闭数据库实例： shutdown abott\n \n2.使用startup命令打开数据库实例\n  (1) 正常启动： startup\n  (2) 以指定的初始化参数文件启动 Startup PFILE=‘’；\n  (3) 启动数据库实例。但不装载数据库 startup nomount\n  (4) 启动数据库实例。装载数据库 startup mount\n  (5) 强制启动数据库实例： startup force\n  (6) 以限制模式启动数据库实例：startup restrict\n  (7) 在数据库启动是开始介质恢复： startup recovery\n  \n  3.使用alter database命令来改变启动模式\n  alter database mount   \n  alter database open\n  alter database open read only\n  \n  \n  ","tags":["Oracle"],"categories":["Oracle"]},{"title":"jQuery的学习--8","url":"/html/jQuery/jQuery的学习--8/","tags":["jQuery","html"],"categories":["html","jQuery"]},{"title":"jQuery的学习--7","url":"/html/jQuery/jQuery的学习--7/","content":"\n\n\n文档处理\n一、添加节点\n ![](https://i.loli.net/2019/05/08/5cd278d3dc5ac.png)\n 1.内部插入\n $(\"ul\").append(\"\");\n append 会将元素添加到指定元素内部的最后\n prepend 会将元素添加到指定元素内部的最前面\n \n appendTo \n prepend  与上面两个一样，书写的格式是反的。\n 2.外部插入\n after 会将元素添加到指定元素外部的后面。\n brfore 会将元素添加到指定元素内部的前面\n \n insertAfter\n insertBefore 与上面两个一样，书写的格式是反的。\n \n 二、删除节点及其相关方法\n  remove() 删除指定元素\n  empty()  清空元素内部内容与子元素\n  detach() 和remove一样\n  \n  \n  三、替换节点\n  replaceWith()  $(\"h1\").replaceWith($h6)\n  replaceAll()    $h6.replaceAll(\"h1\");\n  \n  \n  三、复制节点\n  1.浅复制节点\n  var $li = $(\"li:first\").clone(fasle);  只复制元素，不复制事件\n  2.深复制节点\n  var $li = $(\"li:first\").clone(true);  全部复制\n  ","tags":["jQuery","html"],"categories":["html","jQuery"]},{"title":"jQuery的学习--6","url":"/html/jQuery/jQuery的学习--6/","content":"<escape>淡入和淡出动画,自定义动画，stop和delay方法,图标特效<!-- more --></escape>\n\n一、淡入和淡出动画\n$(\"\").fadeIn(1000,function(){});\n$(\"\").fadeOut(1000,function(){});\n$(\"\").fadeToggle(1000,function(){});\n$(\"\").fadeTo(1000,0.2,function(){});\n\n\n二、自定义动画\n\n$(\"\").animate({},1000,function(){});\n第一个参数可以修改对象属性\nexample：\n$(\".one\").animate({width:500},1000,function(){alert(\"自定义动画\");});  //动画1s后弹出alert\n\n\n时间参数后可以加： linear 和 swing 匀速和缓动  //也可以在基本动画里面使用，一般企业操作不会用\nexample：\n$(\".one\").animate({width:500},1000,\"linear\",function(){alert(\"自定义动画\");});  //动画1s后弹出alert\n$(\".one\").animate({width:500},1000,\"swing\",function(){alert(\"自定义动画\");});  //动画1s后弹出alert\n\n\n属性可以累加\nwidth: \"+=100\"\nexample：\n$(\".one\").animate(width: \"+=100\"},1000,\"swing\",function(){alert(\"自定义动画\");});  //动画1s后弹出alert\n\n关键字:\nwidth: \"hide\"  width: \"toggle\"  \nexample：\n$(\".one\").animate(width: \"hide\"},1000,\"swing\",function(){alert(\"自定义动画\");});  //动画1s后弹出alert\n\n多个属性同时修改会同时执行\n多个单个属性在同一动画队列里会先后执行。\n\n三、jQuery的stop和delay方法\n1.delay\n$(\"\").animate({},1000,function(){}).delay(time).animate({},1000,function(){});;\n$(\".one\").animate(width: \"+=100\"},1000,\"swing\",function(){alert(\"自定义动画\");}).delay(20000).animate(height: \"+=100\"},1000,\"swing\",function(){alert(\"自定义动画\");}); \n2.stop\n(1).$(\"\").stop()；//$(\"\").stop(false)；.$(\"\").stop(false,false)； 没有参数，表示立即停止当前的动画，继续执行后续执行的动画；\n(2).$(\"\").stop(true)；//.$(\"\").stop(true,false)； //立即停止当前和后续的所有动画\n(3).$(\"\").stop(false,true）；//立即完成当前但停止所有后续的后续的所有动画\n\nfinish和stop差不多，不讲了。。\n\n设置\n1.off 打开或关闭全局动画的\njQuery.fc.off=true; 关闭；\n2.interval\njQuery.fc.interval=5;\n默认值是13，值越小，动画越流畅，对浏览器要求越高。\n\n\n\n无限循环滚动:\n{% codeblock %}\n <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>图片滚动</title>\n    <style>\n        *{\n            margin : 0;\n            padding :  0;\n\n        }\n        .imgbox{\n            width:600px;\n            height:300px;\n            margin:100px auto;\n           overflow: hidden;\n\n        }\n        .imgbox>ul{\n            list-style: none;\n            width: 1800px;\n            height:300px;\n            background: black;\n\n        }\n        .imgbox>ul>li{\n            display: inline-block;\n            width: 300px;\n            height: 300px;\n            float:left;\n        }\n        .imgbox>ul>li>span{\n            display: inline-block;\n            background: #2ecc71;\n            width: 300px;\n            height: 300px;\n        }\n    </style>\n     <script src=\"jQuery/js/jquery-3.4.0.min.js\"></script>\n         <script>\n             $(function(){\n               //编写jQuery相关代码\n                 //1.图片设置\n                 var s= [\"#1abc9c\",\"#9b59b6\",\"#e67e22\",\"#95a5a6\",\"#1abc9c\",\"#9b59b6\"];\n                 $(\"li\").each(function (index) {\n                     $(this).children(\"span\").css(\"background\",s[index]);\n                 })\n                 //2.定时器设置\n                 var timer ;\n                 var offset = 0;\n                 function CreateTimer() {\n\n                     timer = setInterval(function () {\n                         offset-=10;\n                         if(offset===-1200) offset=0;\n                         $(\".imgul\").css(\"margin-left\",offset);\n                         console.log(offset);\n                     },50);\n                 }\n                CreateTimer();\n\n                 $(\"li\").hover(function () {\n                         clearInterval(timer);\n                         $(this).siblings().fadeTo(100,0.5);\n                         $(this).fadeTo(100,1);\n                 },\n                 function () {\n                        CreateTimer();\n                     $(\"li\").fadeTo(100,1);\n                 })\n             });\n         </script>\n</head>\n<body>\n<div class=\"imgbox\">\n    <ul class=\"imgul\">\n        <li><span></span></li>\n        <li><span></span></li>\n        <li><span></span></li>\n        <li><span></span></li>\n        <li><span></span></li>\n        <li><span></span></li>\n    </ul>\n</div>\n</body>\n</html>\n \n {% endcodeblock  %}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["jQuery","html"],"categories":["html","jQuery"]},{"title":"jQuery的学习--5","url":"/html/jQuery/jQuery的学习--5/","content":"<escape>jQuery基本动画的显示与隐藏，jQuery 展开和收起动画，对联广告的显示与关闭，折叠菜单<!-- more --></escape>\n\n一、jQuery基本动画的显示与隐藏\n1.$(\"div\").show(1000); //1000ms显示出来\n2.$(\"div\").show(1000，function（）{});\n//动画结束后执行函数\n3.切换动画$(\"div\").toggle(1000)；\n1000ms完成切换。如果隐藏就显示，如果是显示就隐藏.\n'\n\n二、jQuery 展开和收起动画\n$(\"\").slideDown(1000,funciton(){});\n$(\"\").slideUp(1000,funciton(){});\n$(\"\").slideToggle(1000,funciton(){});\n\n\n实例：对联广告的显示与关闭\n{% codeblock %}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>对联广告</title>\n    <style>\n        *{\n            margin: 0;\n            padding: 0;\n        }\n        .img{\n            width:192px;\n            height:240px;\n            position: fixed;\n            top: 40%;\n            display: none;\n        }\n        .left{\n            left: 0%;\n        }\n        .right{\n            right: 0%;\n        }\n\n    </style>\n</head>\n <script src=\"jQuery/js/jquery-3.4.0.min.js\"></script>\n     <script>\n         $(function(){\n           //编写jQuery相关代码\n             $(window).scroll(\n                 function () {\n                     //获取网页滚动偏移位\n                    var offset = $(\"html,body\") .scrollTop();\n                     console.log(offset);\n                     if(offset>=300)\n                        $(\".img\").show(500);\n                    else\n                     $(\".img\").hide(500);\n\n                 }\n             );\n         });\n     </script>\n<body>\n<img class=\"img left\" src=\"img/lisa1.jpg\" alt=\"\">\n<img class=\"img right\"src=\"img/lisa1.jpg\" alt=\"\">\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n</body>\n</html>\n\n{% endcodeblock %}\n\n{% codeblock 折叠菜单 %}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>折叠菜单</title>\n</head>\n<style>\n*{\n    padding: 0;\n    margin: 0;\n\n}\n    .nav{\n        list-style: none;\n        width: 300px;\n        margin: 100px auto;\n    }\n    .nav>li{\n        text-indent: 1em;\n        border: 1px solid #000;\n        line-height: 35px;\n        border-bottom: none;\n        position: relative;\n    }\n  .nav>li:first-child{\n      border-top-left-radius: 10px;\n      border-top-right-radius: 10px;\n  }\n   .nav>li:last-child{\n       border-bottom: 1px solid #000;\n       border-bottom-left-radius: 10px;\n       border-bottom-right-radius: 10px;\n   }\n    .nav>li>span{\n        display: inline-block;\n        position: absolute;\n        right: 20px;\n        top: 10px;\n        width:15px;\n        height: 15px;\n        border-top: 1.5px solid #000;\n        border-right: 1.5px solid #000;\n        transform: rotate(45deg);\n        transition: 0.4s;\n  }\n    .sub{\n        display: none;\n    }\n .sub>li{\n     text-indent: 2em;\n     border: 1px solid #000;\n     line-height: 25px;\n     list-style: none;\n     background: mediumpurple;\n }\n .nav>.c>span{\n     transform: rotate(135deg);\n }\n.sub>li:hover{\n    background: red;\n}\n</style>\n <script src=\"jQuery/js/jquery-3.4.0.min.js\"></script>\n     <script>\n         $(function(){\n           //编写jQuery相关代码\n             //监听一级菜单\n             var level1 = $(\".nav>li\");\n             level1.click(\n                 function () {\n                     //拿二级菜单并展开\n                    var sub =  $(this).children(\".sub\");\n                     console.log($(this).attr(\"class\"));\n                     if ( $(this).attr(\"class\")=== undefined)\n                     $(this).attr(\"class\",\"c\");\n                     else\n                      $(this).removeAttr(\"class\");\n                     sub.slideToggle(200);\n                     $(this).siblings().children(\".sub\").slideUp();\n                     $(this).siblings().removeAttr(\"class\");\n             }\n             );\n         });\n     </script>\n<body>\n<ul class=\"nav\">\n    <li >一级菜单 <span ></span>\n    <ul class=\"sub\">\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n    </ul>\n        </li>\n    <li>一级菜单<span ></span>\n        <ul class=\"sub\">\n            <li>二级菜单</li>\n            <li>二级菜单</li>\n            <li>二级菜单</li>\n            <li>二级菜单</li>\n            <li>二级菜单</li>\n        </ul></li>\n    <li>一级菜单<span ></span>\n    <ul class=\"sub\">\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n    </ul></li>\n    <li>一级菜单<span ></span>\n    <ul class=\"sub\">\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n    </ul></li>\n    <li>一级菜单<span ></span>\n    <ul class=\"sub\">\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n    </ul></li>\n    <li>一级菜单<span ></span>\n    <ul class=\"sub\">\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n    </ul></li>\n    <li>一级菜单<span ></span>\n    <ul class=\"sub\">\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n    </ul></li>\n    <li>一级菜单<span ></span>\n    <ul class=\"sub\">\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n        <li>二级菜单</li>\n    </ul></li>\n</ul>\n</body>\n</html>\n{% endcodeblock %}\n\n\n\n","tags":["jQuery","html"],"categories":["html","jQuery"]},{"title":"jQuery的学习--4","url":"/html/jQuery/jQuery的学习--4/","content":"<escape>事件的绑定,jQuery事件的冒泡和默认的行为，jQuery事件自动触发，自定义事件，jQuery的事件委托 <!-- more --></escape>\n<br>\n\n一、事件的绑定与解绑\n1.$(\"button\").click(function(){});\n2.$(\"button\").on(\"click\",function(){});\n第一种效率高，部分事件jQuery没实现，所以不能添加。\n第二种效率低，时间全\n两者都可以添加多个相同或多个不同内容的事件，且不会被覆盖\n\n\n$(\"button\").off();\n//不传递参数，会移除所有事件\n$(\"button\").off(\"click\");\n//传递一个参数，会移除所有指定类型的事件\n$(\"button\").off(\"click\"，test);\n//传递二个参数，会溢出指定类型的指定事件\n\n\n二、jQuery事件的冒泡和默认的行为\n\n冒泡：子元素事件触发父元素事件\n{% codeblock %}\n$(\".son\").click(function(event){\nalert(\"hh\");\n//两种方式阻止冒泡\n//1.return faslse;\n//2.event.stopPropagation(); \n});\n{% endcodeblock %}\n默认行为:网页元素，都有自己的默认行为，例如，单击超链接会跳转...\n{% codeblock %}\n$(\"a\").click(function(event){\nalert(\"hh\");\n//两种方式阻止默认行为\n//1.return faslse;\n//2.event.preventDefalut(); \n});\n{% endcodeblock %}\n\n三、jQuery事件自动触发\n1.$(\"\").trriger(\"click\");//都会\n2.$(\"\").trrigerHandle(\"click\");//不会触发事件冒泡和默认行为\n\na比较特殊，两种不会有默认行为。\n{% codeblock a的时候自动触发事件且有默认行为 %}\n$(\"span\").click(function(){alert(\"sss\")});\n.$(\"span\").trriger(\"click\");\n.$(\"span\").trrigerHandle(\"click\");\n<a href=\"\"><span>sss</span></a>\n{% endcodeblock %}\n\n\n四、自定义事件\n\n.$(\"span\").on(\"Myclick\"，function(){alert(\"sss\")});\n.$(\"span\").trriger(\"Myclick\");\n\nps:\n1.不能用$(\"\").click;\n2.function(event)不能用event；\n3.必须用trigger触发用on绑定。\n\n\n\n五、jQuery事件命名空间\n.$(\"\").on(\"click.zs\",function(){});\n.$(\"\").on(\"click.ls\",function(){});\n\n.$(\"\").trriger(\"click.zs\");\nps: on+trigger\n\n\njQuery事件命名空间面试题：\n![](https://i.loli.net/2019/04/26/5cc2a4c4c4592.png)\n\n五、jQuery的事件委托\n事件委托:请别人帮忙做事，然后将做完的结果反馈给我们\n\n![](https://i.loli.net/2019/04/26/5cc2a8cf4e86c.png)\n利用已经又得ul来监听还未生成得元素。\n![](https://i.loli.net/2019/04/26/5cc2a935c6767.png)\n\n事件委托例子： 登陆界面的显示\n{% codeblock %}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        *{\n        margin: 0;\n            padding: 0;\n        }\n        html,body{\n            width: 100%;\n            height: 100%;\n        }\n        .mask{\n            width: 100%;\n            height: 100%;\n            background: rgba(0,0,0,0.5);\n            position: fixed;\n\n\n        }\n        .login{\n            width: 656px;\n            height:  360px;\n            margin: 150px auto;\n            position: relative;\n        }\n        .login>span\n        {\n            width: 50px;\n            height: 50px;\n            position: absolute;\n            right: 0px;\n            top: 0px;\n        }\n    </style>\n    <script src=\"register/js/jquery-3.4.0.min.js\"></script>\n         <script>\n             $(function(){\n               //编写jQuery相关代码\n\n                 //\n                 $(\"a\").click(\n                     function()\n                     {\n                         var $mask = $(\" <div class=\\\"mask\\\">\\n\" +\n                             \"        <div class=\\\"login\\\">\\n\" +\n                             \"            <img src=\\\"img/login.png\\\" alt=\\\"\\\">\\n\" +\n                             \"            <span></span>\\n\" +\n                             \"        </div>\\n\" +\n                             \"    </div>\");\n                         $mask.insertBefore(\"a\");\n                    $(\"body\").delegate(\".login>span\",\"click\",function () {\n\n                        $mask.remove();\n                    });\n                         return false;\n                     }\n                 );\n\n\n             });\n         </script>\n</head>\n<body>\n\n<a href=\"\">点我登陆</a>\n\n<span>sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss sssssssssssssssssssssssssssssssssssssssssssssssssssssss</span>\n<div class=\"mask\">\n    <div class=\"login\">\n        <img src=\"img/login.png\" alt=\"\">\n        <span></span>\n    </div>\n</div>\n\n</body>\n</html>\n\n{% endcodeblock %}\n\n\n\n六、jQuery移入移出事件\n//子元素移入移出也会触发父元素事件。\n$(\"\").mouserover();\n$(\"\").mouserout();\n//不会触发父元素的方法\n$(\"\").mouseenter();\n$(\"\").mouseleave();\n$(\"\").mousehover(function(){},function(){});//内部就是enter和leave\n一个参数就是既监听移入又监听移出\n\n实例： Tab选项卡\n{% codeblock %}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Tab选项卡</title>\n    <style>\n        *{\n            margin: 0;\n            padding: 0;\n\n        }\n\n        .box{\n            width:440px;\n            height:300px;\n            margin: 100px auto;\n            border: 1px solid black;\n            overflow: hidden;\n        }\n        .nav>ul>li{\n            list-style: none;\n            width:110px;\n            height:60px;\n            background: orange;\n            line-height: 60px;\n            float: left;\n            text-align: center;\n        }\n        .nav>ul>.current{\n            background: #ccc;\n        }\n        .img>li\n        {\n            list-style: none;\n            display: none;\n        }\n        .img>.show{\n            display: block;\n        }\n        .img>li>img{\n            width:440px ;\n            height: 240px;\n        }\n    </style>\n</head>\n     <script src=\"jQuery/js/jquery-3.4.0.min.js\"></script>\n         <script>\n             $(function(){\n               //编写jQuery相关代码\n                  var $navli =$(\".nav>ul>li\");\n                 $navli.mouseenter(\n                     function () {\n                         $(this).siblings().removeClass();\n                         $(this).addClass(\"current\");\n                         var index = $(this).index();\n                         var $img = $(\".img>li\").eq(index);\n                         $img.siblings().removeClass(\"show\");\n                         $img.addClass(\"show\");\n                     }\n                 );\n\n             });\n         </script>\n<body>\n<div class=\"box\">\n    <div class=\"nav\">\n        <ul>\n            <li class=\"current\">万水千山</li>\n            <li>大雪无痕</li>\n            <li>雨中氤氲</li>\n            <li>雾气弥漫</li>\n        </ul>\n    </div>\n    <ul class=\"img\">\n        <li class=\"show\"><img src=\"img/1.jpg\" alt=\"\"></li>\n        <li><img src=\"img/2.jpg\" alt=\"\"></li>\n        <li><img src=\"img/3.jpg\" alt=\"\"></li>\n        <li><img src=\"img/4.jpg\" alt=\"\"></li>\n    </ul>\n</div>\n</body>\n</html>\n\n{% endcodeblock %}\n\n\n","tags":["jQuery","html"],"categories":["html","jQuery"]},{"title":"jQuery的学习--3","url":"/html/jQuery/jQuery的学习--3/","content":"<escape>类的操作，操作css样式的方法，jQuery位置和尺寸操作的方法，ScrollTop方法 <!-- more --></escape>\n一、类的操作\n1.添加类\n{% codeblock  %}\n.class1{\n padding:10px;\n background:red;\n border: 5px solid red;\n}\n$(\"div\").addClass(\"class1\");\n//想要删除多个类:\n$(\"div\").addClass(\"class1 class2\");\n{%  endcodeblock  %}\n2、 文本值相关操作\n\n{% codeblock  设置html %}\n$(\"div\").html(\"<p>我是段落</p>\");\n{% endcodeblock  %}\n\n{% codeblock  获取html%}\n$(\"div\").html();\n{% endcodeblock  %}\n\n{% codeblock  设置text纯文本 %}\n$(\"div\").html(\"<p>我是段落</p>\");\n{% endcodeblock  %}\n\n{% codeblock  获取纯文本%}\n$(\"div\").html();\n{% endcodeblock  %}\n\n{% codeblock  设置value %}\n$(\"input\").val(\"请输入内容\");\n{% endcodeblock  %}\n\n{% codeblock  获取value%}\n$(\"input\").val(); \n{% endcodeblock  %}\n\n\n二、操作css样式的方法\n\n\n{% codeblock  1.逐个设置 %}\n$(\"div\").css（\"width\",\"100px\"）;\n$(\"div\").css（\"height\",\"100px\"）;\n$(\"div\").css（\"background\",\"red\"）;\n{% endcodeblock  %}\n\n{% codeblock 2.链式设置 %}\n$(\"div\").css（\"width\",\"100px\"）.css（\"height\",\"100px\"）.css（\"background\",\"red\"）;\n/注意点:大于三步建议分开；\n{% endcodeblock %}\n\n{% codeblock 3.批量设置%}\n$(\"div\").css({\nwidth:\"100px\";\nheight: \"100px\";\nbackground: \"red\"\n});\n//企业中建议使用\n{% endcodeblock %}\n\n{% codeblock  1.获取css值 %}\n$(\"div\").css（\"width\"）;\n$(\"div\").css（\"height\"）;\n$(\"div\").css（\"background\"）;\n{% endcodeblock  %}\n\n三、jQuery位置和尺寸操作的方法\n1.$(\".father\").width() //获取元素的宽度\n$(\".father\").width(\"500px\");//设置元素的宽度\n\n2.$(\"son\").offset().left; //获取元素距离窗口的偏移位\n  $(\"son\"). offset({left: 10}); //设置元素距离窗口的偏移位\n\n3.$(\"son\").position().left;//position（） 获取元素距离\n  $(\"son\").css({left: \"10px\"});//position要这样设置\n\n\n定位元素的偏移位置\n{% codeblock %}\n*{ \nmargin: 0;\npadding: 0;\n}\n.faher{\nwidth: 200px;\nheight: 200px;\nbackfround: red;\nmargin-left:50px;\nposition:relative;\n}\n.son{\nwidth: 100px;\nheight: 100px;\nbackgroud: blue;\nposition: absolute;\nleft: 50px;\ntop: 50px;\n}\n<script>\n$(function(){\nvar btns = document.getElementByTagName(\"button\");\n\nbtns[0].onclick=function(){\n//获取元素的宽度\nconsole.log($(\".father\").width());\n//获取元素距离窗口的偏移位\n$(\"son\").offset().left;\n//position（） 获取元素距离定位元素的偏移位置\n$(\"son\").position().left;\n\n};\nbtns[0].onclick=function(){\n//设置元素的宽度\n$(\".father\").width(\"500px\");\n};\n$(\"son\"). offset({left: 10});\n});\n注意点：position方法只能获取不能设置。\n$(\"son\"). position({left: 10});\n});\n$(\"son\").css({left: \"10px\"});//position要这样设置\n\n</script>\n\n<div class=\"father\">\n   <div class=\"son\" >\n   </div> </div>\n<button>获取</button>\n<button>设置</button>\n{% endcodeblock %}\n\n 四、ScrollTop方法\n $(\"\").scrollTop() 获取元素偏移位\n $(\"\").scrollTop(300) 设置元素偏移位\n \n 获取网页移动的偏移位(因为IE里是0)\n $(\"body\").scrollTop() + $(\"html\").scrollTop() ;\n设置网页移动的偏移位\n$(\"html,body\").scrollTop(300)\n\n\n","tags":["jQuery","html"],"categories":["html","jQuery"]},{"title":"JQuery的学习--2","url":"/html/jQuery/jQuery的学习--2/","content":"<escape>  静态方法,jQuery内容选择器,属性和属性节点操作(attr,prop)<!-- more --></escape>\n一、静态方法\n{% codeblock %} \nvar arr = {1,3,5,7,9};\nvar obj ={0:1,1:3,2:5,3:7,5:9}\n\n\n//1.catch方法\n//原生的js可以遍历数组，但不可以遍历伪数组；\n//jQuery可以遍历伪数组\narr.forEach(function(value,index){console.log(index,value);});\nobj.forEach(function(value,index){console.log(index,value);});//控制台会报错\n$each(arr,function(value,index){console.log(index,value);});\n$each(obj,function(value,index){console.log(index,value);});\n\n//2.map方法\narr.map(fucntion(value,index,array){console.loh(value,index,array)});\nobj.map(fucntion(value,index,array){console.loh(value,index,array)});//控制台会报错\n$map(arr,function(value,index){console.log(index,value);});\n$map(obj,function(value,index){console.log(index,value);});\n//jQuery中的each和map的区别 each返回值，遍历谁就返回谁。，map返回空。\n// map可以在function里返回值 return value+index；\n\n//3.trim方法\nvar str = \"    str     \";\nvat res=$.trim(str);\nconsole.log(\"---\"+str+\"---\");\nconsole.log(\"---\"+res+\"---\");\n\n//4.判断是不是window，array，function\n\n var res = $.isWindow(window); //true\n var res = $.isArray(window); //false\n var res = $.isFunction(window); //false\n  var res = $.isFunction(jQuery); //jQuery 本质是一个函数\n \n//5.回复ready时间\n//原生js\nvar btn = document.getElementByTagName(\"button\")[0];\nbtn.onclik = function(){ alert(\"btn\");}\n//暂停ready\n$holdReady(true);\n$(document).ready(function(){});// 等某些元素加载完之后$holdReady(false);回复ready\n  \n{% endcodeblock  %}\n\n二、通过webstorm简化操作\nlive template\n\n三、jQuery内容选择器\n{% codeblock %} \n<div></div>\n<div>我是div</div>\n<div>我是div123456</div>\n<div><span></span></div>\n<div><p></p></div>\n{% endcodeblock %} \n1.：empty\nvar $div = $(\"div:empty\");// 找既没有子元素又没有文本的指定元素\n2.：parent\nvar $div = $(\"div:parent\");// 找有子元素或有文本的指定元素\n3.：contains(text)\nvar $div = $(\"div:contains（'我是div'）\");// 找包含文本内容的指定元素  (是包含而不是等于)\n4.：has\nvar $div = $(\"div:has（'span'）\");// 找包含指定子元素的指定元素\n\n四、属性和属性节点操作  attr prop\n\n![20190425024414185.png](https://i.loli.net/2019/04/25/5cc16bbb116e8.png)\n\n![20190425025458270.png](https://i.loli.net/2019/04/25/5cc16bbb1bb1b.png)\n\n![20190425024938415.png](https://i.loli.net/2019/04/25/5cc16bbb2b7e8.png)\n\n![20190425025606638.png](https://i.loli.net/2019/04/25/5cc16bbb34cdd.png)\n\n![20190425025752787.png](https://i.loli.net/2019/04/25/5cc16bbb0db1c.png)\n\n![20190425030301003.png](https://i.loli.net/2019/04/25/5cc16bbb01eae.png)\n\n![20190425030655089.png](https://i.loli.net/2019/04/25/5cc16bbb20b79.png)\n\n\n$(\"span\").removeAttr(\"class name\");\nspan的class和name属性全部删除。\n\nProp和attr练习实例\n{% codeblock %}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script src=\"js/jquery-3.4.0.min.js\"></script>\n    <script>\n        $(function(){\n          //编写jQuery相关代码\n\n         var button = document.getElementsByTagName(\"button\")[0];\n         button.onclick=function () {\n             var $input = $(\"input\")[0];\n             var text =$input.value;\n             $(\"img\").attr(\"src\",text);\n             //$(\"img\").prop(\"src\",text);\n             console.log(\"ss\");\n         }\n        });\n    </script>\n\n</head>\n<body>\n<input type=\"text\">\n<button> 切换图片</button><br>\n<img src=\"https://www.baidu.com/img/bd_logo1.png\">\n</body>\n</html>\n{% endcodeblock %}\n\n","tags":["jQuery","html"],"categories":["html","jQuery"]},{"title":"jQuery的学习--1","url":"/jQuery/JQuery的学习--1/","content":"<escape>  入口函数，核心函数，静态与实例 <!-- more --></escape>\n一、Jquery入口函数\n{% codeblock %}\n$(document).ready(\nfunction(){\n var $img = $(\"img\")[0];\n console.log($img);\n var width = $img.width;\n console.log(width);\n }\n\n普通JS\nwindow.onload = function(ev)\n{\nvar img = document.getElementByTagName(\"img\")[0];\n console.log(img);\n  var width = img.width;\n console.log(width)\n}\n\n{% endcodeblock %} \n1.原生的js会等到DOM元素加载完毕并等到图片之后才加载，二JQuery会等到DOm元素加载完，但不会等到图片也加载完。\n2.原生的js入口函数会覆盖，JQuery的入口函数不会覆盖；\n\nJQuery的其他入口函数写法 \n1.$(document).ready(function(){}）；\n2.jQuery(document).ready(function(){}）；\n3.$(function(){}）；  //最主要还是用这种方法！\n4.jQuery(function(){}）；\n\n二、jQuery的冲突问题\n$符号在jquery种使用，当在html种引用了别的框架也使用了这个符号的时候就会出现冲突问题； \n一般后引入的框架会覆盖之前引入的框架;\n\n解决方法：\n1.释放$的使用权 jQuery.noConflict(); 用jQuery；释放操作在jQuery代码之前编写。\n2.自定义访问符号 var nc=jQuery.noConflict()；nc(function(){}）；\n\n三、jQuery的核心函数\n$();就代表调用jQuery的核心函数\n{% codeblock %}\n1.接受一个函数 \n$(fuction(){});\n2.接受一个字符串\n2.1接受一个个字符串选择器\nvar $box1 = $(\".box\"); //class div\nvar $box2 = $(\"#box\"); //id div\nconsole($box1);\nconsole($box2);\n2.2接受一个代码片段\nvar $p = $(\"<p>我是锻炼罗</p>);\nconsole.log($p);\n$box1.append($p);\n3.接受一个DOM元素 //会被包装成一个jQuery对象\nvar img = document.getElementByTagName(\"img\")[0];\nvar $i = $(img);\nconsole.long($i);\n{% endcodeblock %}\n\n四、jQuery对象\n本质上是一个伪数组。\nvar $div = $(\"div\");\n\n五、静态方法和实例方法\n静态方法：\n//1.定义一个类\nfunction Aclass(){}\n//2.给这个类添加一个静态方法\nAclass.staticMethod = function(){alert(\"staticMethod\");}\n//3.调用\nAClass.staticMehod();\n\n实例方法：\n//1.给这和类添加一个实例方法\nAclass.prototype.instanceMethod = function(){alert(\"InstanceMethod();}\n//2.创建一个实例（对象）\nvar a = new Aclass():\n//3.调用\na.instanceMethod();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["jQuery","html"],"categories":["jQuery"]},{"title":"html+css--1","url":"/html/html+css_!/","content":"<escape>  好看的前端 <!-- more --></escape>","tags":["html"],"categories":["html"]},{"title":"数据结构--1","url":"/数据结构/数据结构--1/","content":"<escape>  顺序表+栈+链栈 <!-- more --></escape>\n——、顺序表\n顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的各个元素、使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，采用顺序存储结构的线性表通常称为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中\n\n{% codeblock   %}\n#include<iostream>\n\n\n\nusing namespace std;\nconst int MaxSize =100;\n\ntemplate<typename T> class SeqList\n{\n\n    public :\n    SeqList(){;}\n    SeqList(int x){length=x;}\n    SeqList(T a[],int n);\n    ~SeqList(){delete [] data;}\n\n\n    T Get(int i);\n    int Length(){return length;}\n    int Locate(T x);\n    void Insert(int i,T x);\n    T Delete(int x);\n    void PrintList();\n    T Max();\n    T Min();\n\n\n    bool isEmpty(){if(length==0)return true;else return false;}\n    bool isFull(){if(length==MaxSize)return true;else return false;}\n    private:\n    T data[MaxSize];\n    int length;\n\n\n};\n\n\ntemplate<typename T> T SeqList<T>::Max()\n{\n    T max=-1111111;\n    for(int i=0;i<length ;i++)\n    {\n        if(data[i]>max)max=data[i];\n    }\n    return max;\n\n}\ntemplate<typename T> T SeqList<T>::Min()\n{\n    T min=1111111;\n    for(int i=0;i<length ;i++)\n    {\n        if(data[i]<min)min=data[i];\n    }\n    return min;\n}\ntemplate<typename T> SeqList<T>::SeqList(T a[],int n)\n{\n   if(n>MaxSize)throw \"参数违法\";\n   for(int i = 0;i<n;i++)\n   {\n       data[i] = a[i];\n   }\n   length = n;\n}\ntemplate<typename T> T SeqList<T>::Get(int i)\n{\n    if(i<1||i>length)\n    {\n     throw \"位置错误\";\n    }\n    else\n    return data[i-1];\n}\ntemplate<typename T> int SeqList<T>::Locate(T x)\n{\n for(int i=0 ;i<length;i++)\n {\n     if(data[i]=x)return i+1;\n }\n return 0;\n}\ntemplate<typename T> void SeqList<T>::Insert(int i,T x)\n{\n   if(length>=MaxSize)throw \"上溢\";\n   if(i<1||i>length) throw \"位置\";\n    for(int j = i-1; j<length ;j++)\n    {\n        data[j+1]=data[j];\n    }\n    data[i-1]=x;\n}\ntemplate<typename T> T SeqList<T>::Delete(int x)\n{\n\n    if(length==0) throw\"下溢\";\n    if(x<1||x>length) throw \"位置\";\n    T xx=data[x-1];\n    for(int j = x-1; j<length ;j++)\n    {\n        data[j]=data[j+1];\n    }\n    length--;\n    return xx;\n\n}\ntemplate<typename T> void SeqList<T>::PrintList()\n{\n    cout<<\"打印：\";\n\n    for(int i=0;i<length;i++)\n    {\n        cout<<data[i]<<\" \";\n    }\n    cout<<endl;\n}\n\nint main()\n{\n    int a[10];\n    cout<<\"请输入10个数：\"<<endl;\n    for(int i=0;i<10;i++)\n    {\n\n        int x;\n        cin>>x;\n\n        a[i]=x;\n    }\n\n    SeqList<int> se(a,10) ;\n\n    se.PrintList();\n    cout<<\"最大值：\"<<se.Max()<<endl;\n        cout<<\"最小值：\"<<se.Min()<<endl;\n\n}\n\n{%  endcodeblock   %}\n\n二、栈\n\n\n{% codeblock  %}\nSeqStack.h\n#ifndef SEQSTACK_H_INCLUDED\n#define SEQSTACK_H_INCLUDED\n\n\n#include<iostream>\nusing namespace std;\n\ntemplate<typename T>\nclass SeqStack{\n private:\n    T *data;\n    int top ;\n    int max_size;\n\n public:\n  SeqStack(int size):top(-1),max_size(size){\n    data = new T[size];\n    if(data==NULL)\n    {\n        cout<<\"data init error!\"<<endl;\n    }\n\n  }\n  ~SeqStack()\n  {\n      delete []data;\n  }\n\n  public :\n\n   void Push(const T d);\n   T Pop();\n   T GetTop();\n\n   int Length(){return top+1;}\n   bool IsEmpty()const{ return top==-1 ;}\n   void  MakeEmpty()\n   {\n       top=-1;\n   }\n\n    bool IsFull() const{ return top==max_size-1 ;}\n\n\n   void Print();\n\n};\n\n\ntemplate<typename T> void SeqStack<T>::Push(const T d)\n{\n   top++;\n   if(top!=max_size-1)\n   {\n    data[top] = d ;\n   }else\n   {\n       cout<<\"栈已满，溢出\"<<endl;\n   }\n}\ntemplate<typename T> T SeqStack<T>::Pop(){\n  if(!IsEmpty())\n  {\n      top--;\n  }\n  return data[top+1];\n}\ntemplate<typename T> T SeqStack<T>::GetTop(){\n      return data[top];\n}\ntemplate<typename T> void SeqStack<T>::Print(){\n\n     cout<<\"所有栈元素:\";\n  for(int i = top ; i >=0 ; i-- )\n  {\n      cout<<data[i]<<\" \";\n  }\n}\n#endif // SEQSTACK_H_INCLUDED\n\n{% endcodeblock %}\n\n{% codeblock  SeqStackTest %}\n#include<iostream>\n#include \"SeqStack.h\"\n\nbool judge(SeqStack<char> s)\n{\n    int l =s.Length();\n    string s1=\"\",s2=\"\";\n    if(l%2!=0)return false;\n    for(int i=0; i<l/2 ; i++)\n    {\n        s1+=s.Pop();\n    }\n    for(int i=l/2; i<l ; i++)\n    {\n        s2+=s.Pop();\n    }\n    if(s1==s2)\n    return true;\n    return false;\n\n}\nint main()\n{\n    SeqStack<char> s(19);\n    char temp;\n    string ss = \"2+3*(4-{5+2  * 3}\" ;\n    for(int i=0;i<ss.length();i++)\n    {\n        temp=ss[i];\n     if(temp=='{'||temp=='}'||temp=='['||temp==']'||temp=='('||temp==')')\n       {\n         s.Push(temp);\n       }\n\n    }\n  if(judge(s))\n  {\n      cout<<\"匹配\"<<endl;\n  }else\n   cout<<\"no匹配\"<<endl;\n    return 0;\n}\n{% endcodeblock %}\n\n三、链栈\n\n{% codeblock %}\n#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T>\nstruct Node\n{\n    T data;\n    Node<T>*next;\n}Node;\n\ntemplate <class T>\nclass LinkQueue\n{\npublic:\n    LinkQueue();\n    ~LinkQueue(){delete front,rear;}\n    void EnQueue(T x);\n    T DeQueue();\n    T GetQueue();\n    int Empty();\n private:\n    Node<T> *front,*rear;\n};\n\ntemplate <class T>\nLinkQueue<T>::LinkQueue()\n{\n    cout<<\"ss\";\n  front=rear=NULL;\n}\n\ntemplate <class T>\nvoid LinkQueue<T>::EnQueue(T x)\n{\n cout<<\"ss\";\n   Node<T>*s=new Node<T>();\n    s->data=x;\n    s->next=NULL;\n\n   if(front==NULL)\n{\n     front=rear=new Node<T>();\n    front->next=s;\n    rear=front->next;\n    rear=rear->next;\n\n}\n else   rear=rear->next=s;\n    cout<<\"ss\";\n\n\n}\n\ntemplate <class T>\nT LinkQueue<T>::DeQueue()\n{\n\n    if(rear==front) throw\"下溢\";\n    Node<T>*p;\n    T x;\n    p=front->next;\n    x=p->data;\n\n     front->next=p->next;\n\n      if(p->next==NULL) rear=front;\n\n\n\n    p->next=NULL;\n    delete p;\n\n    return x;\n}\n\ntemplate<class T>\nT LinkQueue<T>::GetQueue()\n{\n    return front->next->data;\n}\n\ntemplate<class T>\nint LinkQueue<T>::Empty()\n{\n\n    if(front==rear) return 1;\n    else return 0;\n}\n\nint main()\n{\n    LinkQueue<int> link;\n\n    link.EnQueue(1);\n   // cout<<\"队头元素为：\"<<link.GetQueue()<<endl;\n   // link.EnQueue(3);\n\n    //cout<<\"队头元素为：\"<<link.GetQueue()<<endl;\n   // cout<<\"队列是否为空：\"<<link.Empty()<<endl;\n   // cout<< link.DeQueue()<<endl;\n    //cout<< link.DeQueue()<<endl;\n   // cout<<\"队列是否为空：\"<<link.Empty()<<endl;\n}\n{% endcodeblock %}\n\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"Unity 2d Memory Game 小结。","url":"/Unity/C/Unity_02/","content":"<escape>  Do what I want to do <!-- more --></escape>\n\n\nUnity 2d Memory Game 小结。\n\n两个c#脚本\n\n{% codeblock %}\n\n// 卡背隐藏需要重写\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MeporyCard : MonoBehaviour {\n    [SerializeField] private GameObject cardback;\n    [SerializeField] private SceneController sceneController;\n\n    private int _id;\n    public int id\n    {\n        get\n        {\n            return _id;\n        }\n    }\n    private int _pos;\n    public int pos\n    {\n        get\n        {\n            return _pos;\n        }\n    }\n\t// Use this for initialization\n\tvoid Start () {\n\t\t\n\t}\n\t\n\t// Update is called once per frame\n\tvoid Update () {\n\t\t\n\t}\n    public void OnMouseDown()\n    {\n\n        Debug.Log(\"onMouseDown\");\n        if(cardback.activeSelf&&sceneController.canReaveal())\n        {\n            cardback.SetActive(false);\n            sceneController.setCard(this);\n        }\n        \n    }\n    public void hidden()\n    {\n        this.gameObject.SetActive(false);\n        cardback.SetActive(true);\n        Debug.Log(\"cardback show!\");\n    }\n        \n        public void setCard(int id,Sprite image,int pos)\n    {\n        _pos = pos;\n        _id = id;\n        GetComponent<SpriteRenderer>().sprite = image;\n\n    }\n}\n\n\n{% endcodeblock %}\n\n\n{% codeblock  MeporyCard.cs %}\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SceneController : MonoBehaviour {\n    private int gridRow = 2;\n    private int gridClos = 4;\n\n    private const float offsetX = 2.25f;\n    private const float offsetY = 3.75f;\n\n    private int _score = 0;\n\n    private int _firstCard = -1;\n    private int _secondCard = -1;\n    private MeporyCard[] card = new MeporyCard[9];\n\n    [SerializeField] private  TextMesh text;\n    [SerializeField] private MeporyCard originalCard;\n    [SerializeField] private Sprite[] images;\n\n    // Use this for initialization\n    void Start()\n    {\n        int[] num = { 0, 0, 1, 1, 2, 2, 3, 3 };\n        int[] nums = SufferArray(num);\n        Vector3 startPos = originalCard.transform.position;\n        for (int i = 0; i < gridRow; i++)\n            for (int j = 0; j < gridClos; j++)\n            {\n                \n                if(i==0&j==0)\n                {\n                   card[i*4+j] = originalCard;\n                }else\n                    {\n                    card[i * 4 + j] = Instantiate(originalCard) as MeporyCard;\n                }\n                int index = i * gridClos + j;\n                int id = nums[index];\n                card[i * 4 + j].setCard(id, images[id],i*4+j);\n\n                float posX = (offsetX * j) + startPos.x;\n                float posY = -(offsetY * i) + startPos.y;\n                card[i * 4 + j].transform.position = new Vector3(posX, posY, startPos.y);\n                \n            }\n    }\n    public int[] SufferArray(int[] num)\n    {\n        int[] a = num.Clone() as int[];\n        for(int i = 0;i<a.Length;i++)\n        {\n            int temp = a[i];\n            int r = Random.Range(i, a.Length);\n            a[i] = a[r];\n            a[r] = temp;\n\n        }\n        return a;\n\n    }\n    public bool canReaveal()\n    {\n        if (_firstCard <0 || _secondCard <0)\n        {\n            return true;\n        }\n        return false;\n    }\n    public void setCard(MeporyCard meporyCard)\n    {\n        if (_firstCard <0) _firstCard = meporyCard.pos;\n        else\n        {\n            _secondCard = meporyCard.pos;\n            match();\n        }\n    }\n    public void match()\n    {\n        if(_firstCard==_secondCard)\n        {\n            _score++;\n            ///  text.text = \"Score:\" + _score;\n            hidden();\n            Debug.Log(\"match successful!\");\n\n        }\n        else\n        {\n            //todo 显示错误提示\n            hidden();\n        }\n    }\n    public void hidden()\n    {\n       \n        card[_firstCard].hidden();\n        card[_secondCard].hidden();\n        _firstCard = -1;\n        _secondCard = -1;\n    }\n\t// Update is called once per frame\n    \n\tvoid Update () {\n       \n\t}\n}\n\n{% endcodeblock %}\n","tags":["Unity","C#"],"categories":["Unity","C#"]},{"title":"html+css写简单博客界面的总结","url":"/html/博客html的总结/","content":"<escape> 过放荡不羁的生活，容易得像顺水推舟，但是要结识良朋益友，却难如登天。 —— 巴尔扎克 <!-- more --></escape>\n1. transition\n{% codeblock %}\ndiv\n{\nwidth:100px;\ntransition: width 2s;\n-moz-transition: width 2s; /* Firefox 4 */\n-webkit-transition: width 2s; /* Safari 和 Chrome */\n-o-transition: width 2s; /* Opera */\n}\n{% endcodeblock %}\n\ntansition 属性是一个简写熟悉\n四个过度属性：property、duration、timing-function、delay；\n\n2.opacity\n透明度，0-1之间，0是透明\n3.font-weight\n设置文本的粗细，数值。\n\n4.text-shadow\ntext-shadow: h-shadow v-shadow blur color;\n水平阴影位置、垂直、模糊的距离、阴影的颜色。\n\n5.border-collapse\nborder-collapse 属性设置表格的边框是否被合并为一个单一的边框，还是象在标准的 HTML 中那样分开显示。\nseparate：分开\ncollapse：合并\ninherit：继承父元素\n\n6.position\n{% codeblock %}\nh2\n  {\n  position:absolute;\n  left:100px;\n  top:150px;\n  }\n  {% endcodeblock %}\n  position 属性规定元素的定位类型。\n  这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。\n  \nabsolute\t\n生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。\n\nfixed\t\n生成绝对定位的元素，相对于浏览器窗口进行定位。\n元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。\n\nrelative\t\n生成相对定位的元素，相对于其正常位置进行定位。\n因此，\"left:20\" 会向元素的 LEFT 位置添加 20 像素。\nstatic\t默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。\ninherit\t规定应该从父元素继承 position 属性的值。\n7.max-width\n该属性值会对元素的宽度设置一个最高限制。因此，元素可以比指定值窄，但不能比其宽。不允许指定负值。\n8.display\n//display元素详解\n![](/20190404141825240/20190404022421830.png)\n9.left top right bottom\nleft：该属性定义了定位元素左外边距边界与其包含块左边界之间的偏移。\n其他的依次类推.\n10.鼠标移上去显示全部文本\n white-space: nowrap;\ndisplay: inline-block;\n text-overflow:ellipsis;\n hover：white-space: normal;\n \n 11.  \nDiv分块把每一个元素一层层分开。\ncss文件的开头尽量直接将整将整个html文档的大体约束一下。\n\n像是body元素\n{% codeblock body元素%}\nbody {\n    width: 100%;\n\n}\nbody:before,\nbody:after {\n    content: \"\";\n    display: table;\n}\nbody:after {\n    clear: both;\n}\nhtml,\nbody,\ndiv,\nspan,\napplet,\nobject,\niframe,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\np,\nblockquote,\npre,\na,\nabbr,\nacronym,\naddress,\nbig,\ncite,\ncode,\ndel,\ndfn,\nem,\nimg,\nins,\nkbd,\nq,\ns,\nsamp,\nsmall,\nstrike,\nstrong,\nsub,\nsup,\ntt,\nvar,\ndl,\ndt,\ndd,\nol,\nul,\nli,\nfieldset,\nform,\nlabel,\nlegend,\ntable,\ncaption,\ntbody,\ntfoot,\nthead,\ntr,\nth,\ntd {\n    margin: 0;\n    padding: 0;\n    border: 0;\n    outline: 0;\n    font-weight: inherit;\n    font-style: inherit;\n    font-family: inherit;\n    font-size: 100%;\n    vertical-align: baseline;\n}\nbody {\n    line-height: 1;\n    color: #000;\n    background: #fff;\n}\nol,\nul {\n    list-style: none;\n}\ntable {\n    border-collapse: separate;\n    border-spacing: 0;\n    vertical-align: middle;\n}\ncaption,\nth,\ntd {\n    text-align: left;\n    font-weight: normal;\n    vertical-align: middle;\n}\na img {\n    border: none;\n}\ninput,\nbutton {\n    margin: 0;\n    padding: 0;\n}\ninput::-moz-focus-inner,\nbutton::-moz-focus-inner {\n    border: 0;\n    padding: 0;\n}\n//将所有元素先规范化\n{% endcodeblock %}\n","tags":["html"],"categories":["html"]},{"title":"dao+mysql","url":"/java/4月1日mysql+dao/","content":"<escape>  做自己想做的事情！热爱所热爱的一切！ <!-- more --></escape>\n      \n  mysql       授权用户的修改权限    \n      GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP ON mldn.emp TO 'yqx'@'localhost' IDENTIFIED BY '1234';\n        \n连接数据库并操作\n{% codeblock %}\nclass.forName(Driver)\n Driver ：\"org.git.mm.mysql.driver\" or\n \"com.mysql.jdbc.Driver\"\n \n Connection conn = DriverManager.getConnecttion(\"jdbc:mysql://localhost:3306/mldn,\"yqx\",\"1234\");\n String sql = \"....values(????)\";\n PreparedStatement ps = conn.prepareStatement(sql);\n ps.set....();\n ResultSet rs=ps.executeUpdate(); or ps.executeQuerry();\n \n{% endcodeblock %}\n\nDAO的UML类图\n![](/20190401181232787/20190401104740597.png)\n\n就是代理模式+工厂模式+ ??上下文??\n\n基础类 IEmp_Instance \nEmpDaoProxy拓展了IEmpInstance\n基础DatabaseConnection \ninsatnce 拓展！\n{% codeblock DAO %}\npackage com.yqx.vo;\n\nimport java.util.Date;\n\npublic class Emp {\n   private int empno;\n   private String ename;\n   private String job;\n   private Date hiredate;\n   private float sal;\n   \n   public int getEmpno(){return empno;}\n   public void setEmpno(int empno) {this.empno = empno; }\n   \n   \n  public String getEname()  {  return ename;  }\n  public void setEname(String ename){ this.ename = ename;}\n  \n  public String getJob(){return job;}\n  public void setHJob(String job){this.job = job;}\n  \n  public Date getHiredate(){return hiredate;}\n  public void setHiredate(Date hiredate){this.hiredate = hiredate;}\n  \n  public float getSal(){return sal;}\n  public void setSal(float sal){this.sal = sal;}\n  \n}\n\n\n\npackage com.yqx.dbc;\n\n\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\n\n\n\n\npublic class DatabaseConnection {\n    \n\tprivate final String Driver  =\"com.mysql.jdbc.Driver\" ;\n\tprivate final String Dburl = \"jdbc:mysql://localhost:3306/mldn\";\n\tprivate final String Dbuser = \"yqx\" ;\n\tprivate final String Dbpassword = \"1234\" ;\n\t\n\tprivate Connection conn = null;\n\t\n\tpublic DatabaseConnection()throws Exception{\n\t\ttry{\n\t\t\t\n\t\t\tClass.forName(Driver);\n\t\t\tthis.conn = DriverManager.getConnection(Dburl,Dbuser,Dbpassword);\n\t\t}catch(Exception e)\n\t\t{\n\t\t\tthrow e;\n\t\t}\n\t}\n\tpublic Connection getConnection()\n\t{\n\t\treturn this.conn;\n\t}\n\t\n\tpublic void close() throws Exception{\n\t\tif(this.conn!=null)\n\t\t{\n\t\t\ttry{\n\t\t\tthis.conn.close();\n\t\t}catch(Exception e)\n\t\t{\n\t\t\tthrow e;\n\t\t}\n\t\t}\n\t}\n}\n\n\n\npackage com.yqx.dao;\n\nimport com.yqx.vo.*;\nimport java.util.List;\n\npublic interface IEmpDao {\n      \n\tpublic boolean doCreate(Emp emp)throws Exception;\n\tpublic List<Emp> findAll(String keyword)throws Exception;\n\tpublic Emp findById(int empno)throws Exception;\n\t\n}\n\n\n\n\npackage com.yqx.dao.impl;\n\nimport java.sql.Connection;\nimport java.sql.Date;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.yqx.dao.IEmpDao;\nimport com.yqx.dbc.DatabaseConnection;\nimport com.yqx.vo.Emp;\n\npublic class EmpDao_in implements IEmpDao{\n \n\t\n\tprivate Connection conn  = null;\n\tprivate PreparedStatement ps = null;\n\t\n\tpublic EmpDao_in(DatabaseConnection conn)\n\t{\n\t\tthis.conn = conn.getConnection();\n\t}\n\t@Override\n\tpublic boolean doCreate(Emp emp) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t    \n\t\tboolean flag = false;\n\t\tString sql = \"insert into emp(empno,ename,job,hiredate,sal)values(?,?,?,?,?)\";\n\t\tthis.ps = this.conn.prepareStatement(sql);\n\t\tthis.ps.setInt(1, emp.getEmpno());\n\t\tthis.ps.setString(2, emp.getEname());\n\t\tthis.ps.setString(3, emp.getJob());\n\t\tthis.ps.setDate(4, (Date) new Date(emp.getHiredate().getTime()));\n\t\tthis.ps.setFloat(5, emp.getSal());\n\t\tif(this.ps.executeUpdate()>0)\n\t\t{\n\t\t\tflag= true ; //更新记录的行数大于0\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic List<Emp> findAll(String keyword) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tList<Emp> all = new ArrayList<Emp>();\n\t\tString sql=\"SELECT empno,ename,job,hiredate,sal FROM emp WHERE ename LIKE \" +\n\t\t\t\t\"? OR job LIKE ?\";\n\t\tps = conn.prepareStatement(sql);\n\t\tps.setString(1,\"%\"+keyword+\"%\");\n\t\tps.setString(2, \"%\"+keyword+\"%\");\n\t\n\t\tResultSet rs = ps.executeQuery();\n\t\tEmp emp =null;\n\twhile(rs.next()){\n\t  emp = new Emp();\n\t  emp.setEmpno(rs.getInt(1));\n\t  emp.setEname(rs.getString(2));\n\t  emp.setHJob(rs.getString(3));\n\t  emp.setHiredate(rs.getDate(4));\n\t  emp.setSal(rs.getFloat(5));\n\t  all.add(emp);\n\t}\n\tps.close();\n\treturn all;\n\t\t\n\t\n\t\t\t\n\t}\n\n\t@Override\n\tpublic Emp findById(int empno) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tEmp emp =null;\n\t\tString sql =\"select * from emp where empno=?\";\n\t\tps = conn.prepareStatement(sql);\n\t\tps.setInt(1, empno);\n\t\tResultSet rs = ps.executeQuery();\n\t\twhile(rs.next())\n\t\t{\n\t\t\t  emp = new Emp();\n\t\t\t  emp.setEmpno(rs.getInt(1));\n\t\t\t  emp.setEname(rs.getString(2));\n\t\t\t  emp.setHJob(rs.getString(3));\n\t\t\t  emp.setHiredate(rs.getDate(4));\n\t\t\t  emp.setSal(rs.getFloat(5));\n\t\t\t  \n\t\t}\n\t\tps.close();\n\t\t \n\t\treturn emp;\n\t}\n\n}\n\n\n\npackage com.yqx.dao.proxy;\n\nimport java.util.List;\n\nimport com.yqx.dao.IEmpDao;\nimport com.yqx.dao.impl.EmpDao_in;\nimport com.yqx.dbc.DatabaseConnection;\nimport com.yqx.vo.Emp;\n\n\npublic class EmpDaoProxy implements IEmpDao {\n\tprivate DatabaseConnection dbc = null;\n\tprivate IEmpDao dao =null;\n\tpublic EmpDaoProxy()throws Exception{\n\t\tdbc= new DatabaseConnection();\n\t\tdao = new EmpDao_in(dbc);\n\t}\n\n\t@Override\n\tpublic boolean doCreate(Emp emp) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tboolean flag = false;\n\t\ttry{\n\t\t\tif(this.dao.findById(emp.getEmpno())==null)\n\t\t\t{\n\t\t\t\tflag = this.dao.doCreate(emp);\n\t\t\t}\n\t\t\t\n\t\t}catch(Exception e)\n\t\t{\n\t\t\tthrow e;\n\t\t}finally{\n\t\t\tdbc.close();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic List<Emp> findAll(String keyword) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tList<Emp> all =null;\n\t\ttry{\n\t\t\tall=this.dao.findAll(keyword);\n\t\t\t\t\t\n\t\t}catch(Exception e)\n\t\t{\n\t\t\tthrow e;\n\t\t}\n\t\treturn all;\n\t}\n\n\t@Override\n\tpublic Emp findById(int empno) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tEmp emp = null;\n\t\t\n\t\ttry{\n\t\t\temp=this.dao.findById(empno);\n\t\t\t\n\t\t}catch(Exception e)\n\t\t{\n\t\t\tthrow e;\n\t\t}finally\n\t\t{\n\t\t\tthis.dbc.close();\n\t\t}\n\t\treturn emp;\n\t}\n\n}\n\n\n\npackage com.yqx.dao.factory;\n\nimport com.yqx.dao.IEmpDao;\nimport com.yqx.dao.proxy.EmpDaoProxy;\n\npublic class DAOFactory {\npublic static IEmpDao getIEmpDaoInstance()throws Exception\n{\n\treturn new EmpDaoProxy();\n}\n}\n\n\n\n\npackage com.yqx.dao.test;\n\nimport com.yqx.dao.factory.DAOFactory;\nimport com.yqx.dao.proxy.EmpDaoProxy;\nimport com.yqx.vo.Emp;\n\npublic class TestDaoInsert {\n\n\t/**\n\t * @param args\n\t * @throws Exception \n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n     Emp emp =null;\n     for(int x = 0 ;x < 5; x++)\n     {\n    \t emp = new Emp();\n    \temp.setEmpno(1000+x);\n    \temp.setEname(\"李兴华-\"+x);\n    \temp.setHJob(\"程序员-\"+x);\n    \temp.setHiredate(new java.util.Date());\n    \temp.setSal(500*x);\n    \t\n    \t\n    \t \n         DAOFactory.getIEmpDaoInstance().doCreate(emp);\n     }\n\t}\n\n}\n\n\n{% endcodeblock %}\n\n","tags":["java"],"categories":["java"]},{"title":"Unity---做塔防小Demo时的总结。","url":"/Unity/Unity_01/","content":"<escape>  I fall in love with you ，But you dont konw 。 <!-- more --></escape>\n目标：\n1.看完书\n2.整理几个重要的方法\n\n\n<二>以下是我在做塔防demo游戏时的总结\n1.GameObject 的获取\n\n(1).GameObject.Insatantiate(prefeb,Vector3,Quaternion);\n(2).GameObject gameObject 在属性界面拖入\n\n\n2.Vector3 的用法\n一个向量在另一个向量方向的投影量值 :\nvar fwdSpeed = Vector3.Dot(rigidbody.velocity, transform.forward); // dot 点积\nVector3.Distance()--两点距离\nVector3.Lerp() --差值\nVector3.LerpUnclamped() --钳制差值\nVector3 Cross()--叉积\nVector3.Angle()--两个向量之间的夹角\nVector3.MoveTowards()--移动到目标位置\nVector3.Normalize()--向量单位化\nVector3.Project()-投影于线\nVector3.ProjectOnPlane()-投影于面\nVector3.Reflect()-反射向量\nVector3.Slerp()-球形差值\n\n//https://www.cnblogs.com/yangwx/p/9051639.html\n\n\n3.协程的用法 Yield\n{% codeblock 生成敌人的协程代码 %}\nCoroutine c:\nc = StartCoroutine(SpawnEnemy());\n\nIEnumerator SpawnEnemy()\n{\nforeach(enemy_property e in enemy)\n{\nfor(int i=0 ;i<e.count;i++)\n{\n  GameObject.Instantiate(e.enemyprefab, start.position, Quaternion.identity);  //identity表示无旋转。\n                CountEnemyAlive++;\n                if (i != e.count - 1)\n                yield return new WaitForSeconds(e.time_jiange);  //等待\n}\nwhile (CountEnemyAlive > 0)\n                yield return 0;\n            yield return new WaitForSeconds(time_jiange);  //等待\n}\n}\n\n{% endcodeblock %}\n4.类外调用\n{% codeblock %}\nclass enemyManager....{\n  ....\n  public   enemyManager insatnce;\n  public void  awake{\n      instance = this ;\n  }\n  \n  ...\n}\n\nclass enemy...{\n...\nvoid reach{\nenemyManager.reach--;\n}\n...\n\n}\n\n{% endcodeblock  %}\n\n\n5.Destory(GameObject , time);\n6.两个collider 只设置成Trigger的话\n在那个collider里两个方法\nvoid OnTriggerEnter(Collider col);\nvoid OnTriggerExit(Collider col);\n\n7.renderer.material.color ;\n\n\n\n8.点击\n{% codeblock %}\n void Update()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            if (SelectedTurret != null)\n            { \n                if (EventSystem.current.IsPointerOverGameObject() == false && SelectedTurret.cost != 0)\n                {\n\n                    RaycastHit hit;\n                    Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n\n                    bool isCollider = Physics.Raycast(ray, out hit, 1000, LayerMask.GetMask(\"MapCube\"));\n                    if (isCollider)\n                    {\n\n                        MapCube mapCube = hit.collider.GetComponent<MapCube>();  //得到点击的mapcube\n                        if (mapCube.isHaveTurret == false)\n                        {\n                            //可以创建\n\n                            if (money >= SelectedTurret.cost)\n                            {\n                                Changemoney(-SelectedTurret.cost);\n                                mapCube.BuildTurret(SelectedTurret);\n\n\n                            }\n                            else\n                            {\n                                //钱不够了\n                                moneyAnimator.SetTrigger(\"Fliker\");\n\n                            }\n\n                        }\n                        else if (mapCube.turretgo != null)\n                        {\n                            //TODO 升级处理 \n\n                            if (SelectedTurretgo == mapCube.turretgo && curso.activeInHierarchy)\n                            {\n\n                                HideUpgradeCanvas();\n\n\n                            }\n                            else\n                            {\n                                ShowUpgradeCanvas(mapCube.transform.position, mapCube.isUpgraded);\n                            }\n                            //  Debug.Log(\"SelectedTurretgot赋值\");\n                            selectedMapCube = mapCube;\n                            SelectedTurretgo = mapCube.turretgo;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    {% endcodeblock %}\n    \n    \n    \n    10.视野相机的移动\n{% codeblock %}\n\n        float h = Input.GetAxis(\"Horizontal\");   //ad\n        float v = Input.GetAxis(\"Vertical\");     //ws\n        float mouse = Input.GetAxis(\"Mouse ScrollWheel\");  //鼠标滚轮的滑动\n        transform.Translate(new Vector3(h, mouse*mousespeed, v) * Time.deltaTime * speed,Space.World);\n\n\n{% endcodeblock %}\n\n","tags":["Unity"],"categories":["Unity"]},{"title":"设计模式-装饰模式-复杂的奖金计算","url":"/设计模式/装饰模式/","content":"<escape>一生一代一双人，争教两处销魂。相思相望不相亲，天为谁春？<!--more--></escape>\n复杂的奖金计算\n奖金分类，对于个人有当月奖金、个人累计奖金、个人业务增长奖金、及时回款奖金、限时成交加码奖金等；对于业务主管或者是业务经理，除了个人奖金外，还有团队累积奖金、团队业务增长奖金、团队盈利奖金等。\n计算公式也有不同\n计算奖金金额的基数也有不同\n奖金的计算方式会经常变化。要适于调整和修改\n\n![](/装饰模式/20190326090434377.png)\n复杂的奖金计算：\n\n{% codeblock %}\n\npublic interface IPrize {\n\t public void show();\n}\n\npublic class Concret_Position implements IPrize{\n    private String position ;\n    public Concret_Position(String position)\n    {\n     this.position=position;\n    }\n    public void show()\n    {\n    \t\n    System.out.println(position+\"的奖金分别是：\");\n    }\n    \n}\n\npublic class Prize implements IPrize{\n\n\tprivate IPrize iPrize;\n\tprivate int money;\n\n\tpublic Prize(IPrize iPrize)\n\t{\n         this.iPrize = iPrize;\n\n\t}\n\n\tpublic void show()\n\t{\n\t\tif(iPrize!=null)\n\t\t\tiPrize.show();\n\t}\n}\n\n\n//个人累计奖金\npublic class Accu_Prize extends Prize{\n\n    private int money;\n    \n    public Accu_Prize(IPrize iPrize)\n    {\n    \tsuper(iPrize);\n    \tmoney=0;//个人累计奖金算法\n    }\n  \n   public void show()\n   {\n\t   super.show();\n         System.out.print(\"个人累计奖金:\"+money+\" \");\n   } \n\n\n}\n\n\n//限时成交加码奖金\npublic class Deal_Prize extends Prize{\n\n    private int money;\n    \n    public Deal_Prize(IPrize iPrize)\n    {\n    \tsuper(iPrize);\n    \tmoney=0;//个人业务增长奖金算法\n    }\n  \n   public void show()\n   {\n\t     super.show();\n         System.out.print(\"限时成交加码奖金:\"+money+\" \");\n   } \n\n\n}\n\n\n//个人业务增长奖金\npublic class Incr_Prize extends Prize{\n\n    private int money;\n    \n    public Incr_Prize(IPrize iPrize,int Incr)\n    {\n    \tsuper(iPrize);\n    \tmoney=(int) (Incr*0.3);//个人业务增长奖金算法\n    }\n  \n   public void show()\n   {\n\t   super.show();\n         System.out.print(\"个人业务增长奖金:\"+money+\" \");\n   } \n\n\n}\n\n\n//个人当月奖金\npublic class Month_Prize extends Prize{\n\n    private int money;\n    \n    public Month_Prize(IPrize iPrize)\n    {\n    \tsuper(iPrize);\n    \tmoney=0;//个人当月奖金算法\n    }\n  \n   public void show()\n   {\n\t   super.show();\n         System.out.print(\"个人当月奖金:\"+money+\" \");\n   } \n\n\n}\n\n//即时回款奖金\npublic class Payb_Prize extends Prize{\n\n    private int money;\n    \n    public Payb_Prize(IPrize iPrize)\n    {\n    \tsuper(iPrize);\n    \tmoney=0;//即时回款奖金算法\n    }\n  \n   public void show()\n   {\n         \n\t   super.show();System.out.print(\"即时回款奖金:\"+money+\" \");\n   } \n\n\n}\n\n//团队累积奖金\npublic class T_Accu_Prize extends Prize{\n\n    private int money;\n    \n    public T_Accu_Prize(IPrize iPrize)\n    {\n    \tsuper(iPrize);\n    \tmoney=0;\n    }\n  \n   public void show()\n   {\n\t   super.show();System.out.println(\"团队累积奖金:\"+money+\" \");\n   } \n\n\n}\n\n\n//团队业务增长奖金\npublic class T_Incr_Prize extends Prize{\n\n    private int money;\n    \n    public T_Incr_Prize(IPrize iPrize)\n    {\n    \tsuper(iPrize);\n    \tmoney=0;//团队业务增长奖金算法\n    }\n  \n   public void show()\n   {\n\t   super.show(); System.out.println(\"团队业务增长奖金:\"+money+\" \");\n   } \n\n\n}\n\n\n//团队盈利奖金\npublic class T_Pro_Prize extends Prize{\n\n    private int money;\n    \n    public T_Pro_Prize(IPrize iPrize)\n    {\n    \tsuper(iPrize);\n    \tmoney=0;//团队盈利奖金算法\n    }\n  \n   public void show()\n   {\n\t   super.show(); System.out.println(\"团队盈利奖金:\"+money+\" \");\n   } \n\n\n}\n// 策略\npublic class Context {\n \n\tprivate String position;\n\tpublic Context(String position)\n\t{\n\t\tthis.position = position;\n\t}\n\tpublic void show()\n\t{      \n\t\tConcret_Position cp;\n\t\t\n\t\tcp = new Concret_Position(position);\n\t\t\n\t\tPrize iP =(Prize) new Incr_Prize(cp,1000);\n\t\tPrize dP =(Prize) new Deal_Prize(iP);\n\t\tPrize mP =(Prize)  new Month_Prize(dP);\n\t\tPrize pP =(Prize) new Payb_Prize(mP);\n\t\tPrize aP =(Prize)  new Accu_Prize(pP);\n\t\t\n\t\tif(position!=\"普通职员\")\n\t\t{\n\t\t\t/*Prize taP =(Prize)  new T_Accu_Prize(aP);\n\t\t\tPrize tiP =(Prize)  new T_Incr_Prize(taP);\n\t\t\tPrize tpP =(Prize)  new T_Pro_Prize(tiP);\n\t\t\t*/\n\t\t\tPrize tpP = new T_Pro_Prize(new T_Incr_Prize(new T_Accu_Prize(aP)));\n\t\t\ttpP.show();\n\t\t\t\n\t\t}\n\t\telse\n\t\t\taP.show();\n\t\t\n\t}\n}\n\n//客户端\npublic class Client {\n\tpublic static void main(String[] args)\n\t{\n\t\tContext c1,c2;\n\t\tString s1 = \"普通职员\" ;\n\t\tString s2 = \"高级职员\";\n\t\t\n\t\tc1 = new Context(s1);\n\t\t\n\t\tc2 = new Context(s2);\n\t\t\n\t\tc1.show();System.out.println(\"\");\n\t\tc2.show();\n\t\t\n\t}\n\n}\n\n\n {% endcodeblock %}\n \n 结果是：  \n \n普通职员的奖金分别是：\n个人业务增长奖金:300 限时成交加码奖金:0 个人当月奖金:0 即时回款奖金:0 个人累计奖金:0 \n高级职员的奖金分别是：\n个人业务增长奖金:300 限时成交加码奖金:0 个人当月奖金:0 即时回款奖金:0 个人累计奖金:0 团队累积奖金:0 \n团队业务增长奖金:0 \n团队盈利奖金:0 \n\n\n只在个人业务增长奖金出加了计算。","tags":["设计模式"],"categories":["设计模式"]},{"title":"html引用css","url":"/html的学习/html引用css/","content":"\n<escape>  to be or not to be ,thats a question <!-- more --></escape>\n![](https://i.loli.net/2019/03/25/5c9842529f2a1.png)\n\n\n\n4种方式引用css样式表\n\n{% codeblock %}\n1. <h style=\"line-height=40px\"></h>\n2. <style>.h{line-hejght:40px;}</style>\n3. <style type=\"text/css\" ><!--@import url(xxx.css)--></style>\n4. <link rel=\"stylesheet\" href=\"xxx.css\" type=\"text/css\"/>\n{% endcodeblock %}","tags":["html"],"categories":["html的学习"]},{"title":"webstorm 编写html的快捷键","url":"/html的学习/webstorm-编写html的快捷键/","content":"<escape>  真理惟一可靠的标准就是永远自相符合。 —— 欧文 <!-- more --></escape>\n下面是Webstorm的一些常用快捷键：\n1. ctrl + shift + n: 打开工程中的文件，目的是打开当前工程下任意目录的文件。\n2. ctrl + j: 输出模板\n3. ctrl + b: 跳到变量申明处\n4. ctrl + alt + T: 围绕包裹代码(包括zencoding的Wrap with Abbreviation)\n5. ctrl + []: 匹配 {}[]\n6. ctrl + F12: 可以显示当前文件的结构\n7. ctrl + x: 剪切(删除)行，不选中，直接剪切整个行，如果选中部分内容则剪切选中的内容\n8. alt + left/right:标签切换\n9. ctrl + r: 替换\n10. ctrl + shift + up: 行移动\n11. shift + alt + up: 块移动(if(){},while(){}语句块的移动)\n12. ctrl + d: 行复制\n13. ctrl + shift + ]/[: 选中块代码\n14. ctrl + / : 单行注释\n15. ctrl + shift + / : 块注释\n16. ctrl + shift + i : 显示当前CSS选择器或者JS函数的详细信息\n17. ctrl + '-/+': 可以折叠项目中的任何代码块，它不是选中折叠，而是自动识别折叠。\n18. ctrl + '.': 折叠选中的代码的代码。<br>\n ctrl+/ 单行注释<br>\nctrl+shift+/块注释<br>\nctrl+shift+ +/-展开/折叠<br>\nctrl+alt+L 格式化代码<br>\nctrl+shift+ up/down 上下移动句子<br>\nAlt+回车 导入包,自动修正<br>\nCtrl+N 查找类<br>\nCtrl+Shift+N 查找文件<br>\nCtrl+Alt+L 格式化代码<br>\nCtrl+Alt+O 优化导入的类和包<br>\nAlt+Insert 生成代码(如get,set方法,构造函数等)<br>\nCtrl+E或者Alt+Shift+C 最近更改的代码<br>\nCtrl+R 替换文本<br>\nCtrl+F 查找文本<br>\nCtrl+Shift+Space 自动补全代码<br>\nCtrl+空格 代码提示<br>\nCtrl+Alt+Space 类名或接口名提示<br>\nCtrl+P 方法参数提示<br>\nCtrl+Shift+Alt+N 查找类中的方法或变量<br>\nAlt+Shift+C 对比最近修改的代码<br>\nShift+F6 重构-重命名<br>\nCtrl+Shift+先上键<br>\nCtrl+X 删除行<br>\nCtrl+D 复制行<br>\nCtrl+/ 或 Ctrl+Shift+/ 注释（// 或者/*...*/ ）<br>\nCtrl+J 自动代码<br>\nCtrl+E 最近打开的文件<br>\nCtrl+H 显示类结构图<br>\nCtrl+Q 显示注释文档<br>\nAlt+F1 查找代码所在位置<br>\nAlt+1 快速打开或隐藏工程面板\nCtrl+Alt+ left/right 返回至上次浏览的位置<br>\nAlt+ left/right 切换代码视图<br>\nAlt+ Up/Down 在方法间快速移动定位<br>\nCtrl+Shift+Up/Down 代码向上/下移动。<br>\nF2 或Shift+F2 高亮错误或警告快速定位<br>\n代码标签输入完成后，按Tab，生成代码。<br>\n选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br>\nCtrl+W 选中代码，连续按会有其他效果<br>\n选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br>\nCtrl+Up/Down 光标跳转到第一行或最后一行下<br>\nCtrl+B 快速打开光标处的类或方法<br>\n","tags":["html"],"categories":["html的学习"]},{"title":"html ：before ：after的运用","url":"/html的学习/html-：：before-：：after的运用/","content":"<escape>  如果我看穿你的思念，我就不会为你哭红双眼 <!-- more --></escape>\n：before和：after时css中的一种伪元素\n：before 就是在某个元素之前插入内容\n: after  就是在某个元素之后插入内容\n\n{% codeblock  hello world lang:html %}\n<style>\n    p:before{\n        content: \"H\"  /*:before和:after必带技能，重要性为满5颗星*/\n    }\n    p:after{\n        content: \"d\"  /*:before和:after必带技能，重要性为满5颗星*/\n    }\n  </style>\n  <p>ello Worl</p>\n  {% endcodeblock %}\n \n  \n  \n  边框一个正方形里四个三角形\n  {% codeblock %}\n  <style>\n    .triangle{\n        width: 0;\n        height: 0;\n        border-left:50px solid red;\n        border-bottom:50px solid blue;\n        border-top:50px solid black;\n        border-right:50px solid purple\n    }\n  </style>\n  <div class=\"triangle\"></div>\n  {% endcodeblock %}\n   结果展示：\n   \n  <style>\n    .triangle{\n        width: 0;\n        height: 0;\n        border-left:50px solid red;\n        border-bottom:50px solid blue;\n        border-top:50px solid black;\n        border-right:50px solid purple\n    }\n  </style>\n  <div class=\"triangle\"></div>\n  \n  \n  {% codeblock %}\n  .triangle{\n      width: 0;\n      height: 0;\n      border:50px solid transparent; /*这里我们将元素的边框宽度设置为50px，transparent表示边框颜色是透明的，solid表示边框是实线的*/\n      border-top-color: black;  /*这里我们仅将上边框的颜色设置为黑色，众所周知，css后面的样式代码会覆盖之前的相同的样式代码，至于其他三边的还是透明色*/\n      /*border-bottom-color: black; //这里设置底部边框色为黑色\n        border-left-color: black;   //这里设置左边边框色为黑色\n        border-right-color:black    //这里设置右边边框色为黑色*/\n  }\n  {% endcodeblock %}\n  结果展示：\n  \n  <style>\n  .triangle_1{\n      width: 0;\n      height: 0;\n      border:50px solid transparent; \n      border-top-color: black; \n  }\n  </style>\n  <div class=\"triangle_1\"></div>\n  {% codeblock  没有加入before after 的情况%}\n  <style>\n    .test-div{\n        position: relative;  /*日常相对定位*/\n        width:150px;\n        height:36px;\n        border-radius:5px;\n        border:black 1px solid;\n        background: rgba(245,245,245,1)\n    }\n    .test-div:before{\n        content: \"\";  /*:before和:after必带技能，重要性为满5颗星*/\n        display: block;\n        position: absolute;  /*日常绝对定位*/\n        top:8px;\n        width: 0;\n        height: 0;\n        border:6px solid transparent;\n        left:-12px;\n        border-right-color: rgba(245,245,245,1);\n    }\n  </style>\n  <div class=\"test-div\"></div>\n  {% endcodeblock %}\n  \n  {% codeblock %}\n  <style>\n    .test-div{\n        position: relative;  /*日常相对定位*/\n        width:150px;\n        height: 36px;\n        border:1px solid black;\n        border-radius:5px;\n        background: rgba(245,245,245,1)\n    }\n    .test-div:before,.test-div:after{\n        content: \"\";  /*:before和:after必带技能，重要性为满5颗星*/\n        display: block;\n        position: absolute;  /*日常绝对定位*/\n        top:8px;\n        width: 0;\n        height: 0;\n        border:6px solid transparent;\n    }\n    .test-div:before{\n        left:-11px;\n        border-right-color: rgba(245,245,245,1);\n        z-index:1\n    }\n    .test-div:after{\n        left:-12px;\n        border-right-color: rgba(0,0,0,1);\n        z-index: 0\n    }\n  </style>\n  <div class=\"test-div\"></div>\n  {% endcodeblock %}\n  \n  搬运链接：https://www.cnblogs.com/ys-ys/p/5092760.html","tags":["html"],"categories":["html的学习"]},{"title":"Hexo的认识-1","url":"/hexo的学习/虞启贤的第二篇/","content":"<escape>  I can do anything --steph curry <!-- more --></escape>\n在知道有hexo这个东西前，由于对github和echarts的使用，我电脑中的git、node.js、npm（node.js已经集成了npm）的安装已经全部完成。\n\nnode.js安装：https://blog.csdn.net/weixin_41585557/article/details/79155526\n{% codeblock  %}\n$npm config set cache \"D:\\Program \n{% endcodeblock %}\nFiles\\Nodejs\\node_global\"  //配置npm的全局模块的存放路径以及cache的路径。\n{% codeblock %}\n$npm config set prefix \"D:\\Program \nFiles\\Nodejs\\node_cache\"\n{% endcodeblock %}\n二、\n在b站的视频中安装hexo是在cmd 用 \n{% codeblock  %}\nnpm install hexo-cli -g. \n//-g这里是全局的意思。npm install 本地安装与全局安装的区别：https://www.cnblogs.com/qiangxia/p/5264720.html\n{% endcodeblock %}\n我安装的是\n\n{% codeblock  %}\nnpm install hexo -g\n{% endcodeblock %}\n\nhexo-cli与hexo的关系 http://www.one-more-tech.info/Hexo-%E4%B8%8E-Hexo-cli-%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/index/\n\n这时可以用 hexo -v 查看hexo版本 在cmd和git中操作都可以，我是选择在git中操作。\nps：这时有可能会说hexo不是命令或不是外部命令，这是因为系统环境变量加到path之后\nC:\\Users\\ajwlf\\node_modules\\hexo\\node_modules\\.bin 这里的.bin里面只有两个文件，千万不要去找install到npm里的hexo的.bin，一定是在c盘。\n这里我耽误了好长时间，就是因为没找到。。。甚至一度以为时出了别的问题，重新下载了好几遍hexo和hexo-cli\n\n三、安装hexo\n安装完之后对博客文件（随便建一个空文件即可）夹进行gitbash 将hexo安装到博客文件夹\n{% codeblock  %}\nhexo init\n{% endcodeblock  %}\n之后就是基本的hexo操作了\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n","tags":["hexo"],"categories":["hexo的学习"]},{"title":"虞启贤的第一篇博客文章","url":"/diary/hello-world/","content":"<escape>  世界本没有路，走的人多了便成了路。 感谢HEXO <!-- more --></escape>\n额，努力多写，努力搬运！\n\n","tags":["diary"],"categories":["diary"]}]